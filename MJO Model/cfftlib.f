C***************************************************************
C    THIS LIB CONTAINS THE FOLLOWING PACKAGES                  C
C                                                              C
C    (1) TEMPERTON'S FFT PACKAGE                               C
C                                                              C
C    (2) FULTON'S FAST CHEBYSHEV TRANSFORM PACKAGE (no CTRAN!) C
C                                                              C
C    (3) FULTON'S CHEBYSHEV SOLVER                             C
C                                                              C
C    (4) FULTON'S DERIVATIVE IN FOURIER SPECTRAL SPACE         C
C                                                              C
C    (5) KUO'S SINGLE SINE, COSINE AND DERIVATIVE TRANSFORM    C
C                                                              C
C***************************************************************
      SUBROUTINE FFT99(A,WORK,TRIGS,IFAX,INC,JUMP,N,LOT,ISIGN)
C
C PURPOSE      PERFORMS MULTIPLE FAST FOURIER TRANSFORMS.  THIS PACKAGE
C              WILL PERFORM A NUMBER OF SIMULTANEOUS REAL/HALF-COMPLEX
C              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE
C              TRANSFORMS, I.E.  GIVEN A SET OF REAL DATA VECTORS, THE
C              PACKAGE RETURNS A SET OF 'HALF-COMPLEX' FOURIER
C              COEFFICIENT VECTORS, OR VICE VERSA.  THE LENGTH OF THE
C              TRANSFORMS MUST BE AN EVEN NUMBER GREATER THAN 4 THAT HAS
C              NO OTHER FACTORS EXCEPT POSSIBLY POWERS OF 2, 3, AND 5.
C              THIS IS AN ALL FORTRAN VERSION OF THE CRAYLIB PACKAGE 
C              THAT IS MOSTLY WRITTEN IN CAL.
C
C              THE PACKAGE FFT99F CONTAINS SEVERAL USER-LEVEL ROUTINES:
C
C            SUBROUTINE FFTFAX
C                AN INITIALIZATION ROUTINE THAT MUST BE CALLED ONCE
C                BEFORE A SEQUENCE OF CALLS TO THE FFT ROUTINES
C                (PROVIDED THAT N IS NOT CHANGED).
C
C            SUBROUTINES FFT99 AND FFT991
C                TWO FFT ROUTINES THAT RETURN SLIGHTLY DIFFERENT
C                ARRANGEMENTS OF THE DATA IN GRIDPOINT SPACE.
C
C
C ACCESS       THIS FORTRAN VERSION MAY BE ACCESSED WITH
C
C                   *FORTRAN,P=XLIB,SN=FFT99F
C
C              TO ACCESS THE CRAY OBJECT CODE, CALLING THE USER ENTRY
C              POINTS FROM A CRAY PROGRAM IS SUFFICIENT.  THE SOURCE 
C              FORTRAN AND CAL CODE FOR THE CRAYLIB VERSION MAY BE
C              ACCESSED USING
C
C                   FETCH P=CRAYLIB,SN=FFT99
C                   FETCH P=CRAYLIB,SN=CAL99
C
C USAGE        LET N BE OF THE FORM 2**P * 3**Q * 5**R, WHERE P .GE. 1,
C              Q .GE. 0, AND R .GE. 0.  THEN A TYPICAL SEQUENCE OF
C              CALLS TO TRANSFORM A GIVEN SET OF REAL VECTORS OF LENGTH
C              N TO A SET OF 'HALF-COMPLEX' FOURIER COEFFICIENT VECTORS
C              OF LENGTH N IS
C
C                   DIMENSION IFAX(13),TRIGS(3*N/2+1),A(M*(N+2)),
C                  +          WORK(M*(N+1))
C
C                   CALL FFTFAX (N, IFAX, TRIGS) 
c                   CALL FFT99 (A,WORK,TRIGS,IFAX,INC,JUMP,N,M,ISIGN)
C
C              SEE THE INDIVIDUAL WRITE-UPS FOR FFTFAX, FFT99, AND
C              FFT991 BELOW, FOR A DETAILED DESCRIPTION OF THE
C              ARGUMENTS.
C
C HISTORY      THE PACKAGE WAS WRITTEN BY CLIVE TEMPERTON AT ECMWF IN
C              NOVEMBER, 1978.  IT WAS MODIFIED, DOCUMENTED, AND TESTED
C              FOR NCAR BY RUSS REW IN SEPTEMBER, 1980.
C
C-----------------------------------------------------------------------
C
C SUBROUTINE FFTFAX (N,IFAX,TRIGS)
C
C PURPOSE      A SET-UP ROUTINE FOR FFT99 AND FFT991.  IT NEED ONLY BE
C              CALLED ONCE BEFORE A SEQUENCE OF CALLS TO THE FFT
C              ROUTINES (PROVIDED THAT N IS NOT CHANGED).
C
C ARGUMENT     IFAX(13),TRIGS(3*N/2+1) 
C DIMENSIONS
C
C ARGUMENTS
C
C ON INPUT     N
C               AN EVEN NUMBER GREATER THAN 4 THAT HAS NO PRIME FACTOR
C               GREATER THAN 5.  N IS THE LENGTH OF THE TRANSFORMS (SEE
C               THE DOCUMENTATION FOR FFT99 AND FFT991 FOR THE
C               DEFINITIONS OF THE TRANSFORMS).
C
C              IFAX
C               AN INTEGER ARRAY.  THE NUMBER OF ELEMENTS ACTUALLY USED
C               WILL DEPEND ON THE FACTORIZATION OF N.  DIMENSIONING 
C               IFAX FOR 13 SUFFICES FOR ALL N LESS THAN A MILLION.
C
C              TRIGS
C               A FLOATING POINT ARRAY OF DIMENSION 3*N/2 IF N/2 IS
C               EVEN, OR 3*N/2+1 IF N/2 IS ODD.
C
C ON OUTPUT    IFAX
C               CONTAINS THE FACTORIZATION OF N/2.  IFAX(1) IS THE
C               NUMBER OF FACTORS, AND THE FACTORS THEMSELVES ARE STORED
C               IN IFAX(2),IFAX(3),...  IF FFTFAX IS CALLED WITH N ODD,
C               OR IF N HAS ANY PRIME FACTORS GREATER THAN 5, IFAX(1)
C               IS SET TO -99.
C
C              TRIGS
C               AN ARRAY OF TRIGNOMENTRIC FUNCTION VALUES SUBSEQUENTLY
C               USED BY THE FFT ROUTINES.
C
C-----------------------------------------------------------------------
C
C SUBROUTINE FFT991 (A,WORK,TRIGS,IFAX,INC,JUMP,N,M,ISIGN) 
C                       AND
C SUBROUTINE FFT99 (A,WORK,TRIGS,IFAX,INC,JUMP,N,M,ISIGN)
C
C PURPOSE      PERFORM A NUMBER OF SIMULTANEOUS REAL/HALF-COMPLEX
C              PERIODIC FOURIER TRANSFORMS OR CORRESPONDING INVERSE
C              TRANSFORMS, USING ORDINARY SPATIAL ORDER OF GRIDPOINT 
C              VALUES (FFT991) OR EXPLICIT CYCLIC CONTINUITY IN THE
C              GRIDPOINT VALUES (FFT99).  GIVEN A SET
C              OF REAL DATA VECTORS, THE PACKAGE RETURNS A SET OF
C              'HALF-COMPLEX' FOURIER COEFFICIENT VECTORS, OR VICE
C              VERSA.  THE LENGTH OF THE TRANSFORMS MUST BE AN EVEN
C              NUMBER THAT HAS NO OTHER FACTORS EXCEPT POSSIBLY POWERS
C              OF 2, 3, AND 5.  THESE VERSION OF FFT991 AND FFT99 ARE
C              OPTIMIZED FOR USE ON THE CRAY-1.
C
C ARGUMENT     A(M*(N+2)), WORK(M*(N+1)), TRIGS(3*N/2+1), IFAX(13)
C DIMENSIONS
C
C ARGUMENTS
C
C ON INPUT     A
C               AN ARRAY OF LENGTH M*(N+2) CONTAINING THE INPUT DATA 
C               OR COEFFICIENT VECTORS.  THIS ARRAY IS OVERWRITTEN BY
C               THE RESULTS. 
C
C              WORK
C               A WORK ARRAY OF DIMENSION M*(N+1)
C
C              TRIGS
C               AN ARRAY SET UP BY FFTFAX, WHICH MUST BE CALLED FIRST.
C
C              IFAX
C               AN ARRAY SET UP BY FFTFAX, WHICH MUST BE CALLED FIRST.
C
C              INC 
C               THE INCREMENT (IN WORDS) BETWEEN SUCCESSIVE ELEMENTS OF
C               EACH DATA OR COEFFICIENT VECTOR (E.G.  INC=1 FOR
C               CONSECUTIVELY STORED DATA).
C
C              JUMP
C               THE INCREMENT (IN WORDS) BETWEEN THE FIRST ELEMENTS OF
C               SUCCESSIVE DATA OR COEFFICIENT VECTORS.  ON THE CRAY-1,
C               TRY TO ARRANGE DATA SO THAT JUMP IS NOT A MULTIPLE OF 8
C               (TO AVOID MEMORY BANK CONFLICTS).  FOR CLARIFICATION OF
C               INC AND JUMP, SEE THE EXAMPLES BELOW.
C
C              N
C               THE LENGTH OF EACH TRANSFORM (SEE DEFINITION OF
C               TRANSFORMS, BELOW).
C
C              M
C               THE NUMBER OF TRANSFORMS TO BE DONE SIMULTANEOUSLY.
C
C              ISIGN
C               = +1 FOR A TRANSFORM FROM FOURIER COEFFICIENTS TO
C                    GRIDPOINT VALUES. 
C               = -1 FOR A TRANSFORM FROM GRIDPOINT VALUES TO FOURIER
C                    COEFFICIENTS.
C
C ON OUTPUT    A
C               IF ISIGN = +1, AND M COEFFICIENT VECTORS ARE SUPPLIED
C               EACH CONTAINING THE SEQUENCE:
C
C               A(0),B(0),A(1),B(1),...,A(N/2),B(N/2)  (N+2 VALUES)
C
C               THEN THE RESULT CONSISTS OF M DATA VECTORS EACH
C               CONTAINING THE CORRESPONDING N+2 GRIDPOINT VALUES:
C
C               FOR FFT991, X(0), X(1), X(2),...,X(N-1),0,0.
C               FOR FFT99, X(N-1),X(0),X(1),X(2),...,X(N-1),X(0).
C                   (EXPLICIT CYCLIC CONTINUITY) 
C
C               WHEN ISIGN = +1, THE TRANSFORM IS DEFINED BY:
C                 X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N))
C                 WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K)
C                 AND I=SQRT (-1)
C
C               IF ISIGN = -1, AND M DATA VECTORS ARE SUPPLIED EACH
C               CONTAINING A SEQUENCE OF GRIDPOINT VALUES X(J) AS
C               DEFINED ABOVE, THEN THE RESULT CONSISTS OF M VECTORS 
C               EACH CONTAINING THE CORRESPONDING FOURIER COFFICIENTS
C               A(K), B(K), 0 .LE. K .LE N/2.
C
C               WHEN ISIGN = -1, THE INVERSE TRANSFORM IS DEFINED BY:
C                 C(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*EXP(-2*I*J*K*PI/N))
C                 WHERE C(K)=A(K)+I*B(K) AND I=SQRT(-1)
C
C               A CALL WITH ISIGN=+1 FOLLOWED BY A CALL WITH ISIGN=-1
C               (OR VICE VERSA) RETURNS THE ORIGINAL DATA. 
C
C               NOTE: THE FACT THAT THE GRIDPOINT VALUES X(J) ARE REAL
C               IMPLIES THAT B(0)=B(N/2)=0.  FOR A CALL WITH ISIGN=+1,
C               IT IS NOT ACTUALLY NECESSARY TO SUPPLY THESE ZEROS.
C
C EXAMPLES      GIVEN 19 DATA VECTORS EACH OF LENGTH 64 (+2 FOR EXPLICIT
C               CYCLIC CONTINUITY), COMPUTE THE CORRESPONDING VECTORS OF
C               FOURIER COEFFICIENTS.  THE DATA MAY, FOR EXAMPLE, BE 
C               ARRANGED LIKE THIS:
C
C FIRST DATA   A(1)=    . . .                A(66)=             A(70)
C VECTOR       X(63) X(0) X(1) X(2) ... X(63) X(0)  (4 EMPTY LOCATIONS)
C
C SECOND DATA  A(71)=   . . .                                  A(140)
C VECTOR       X(63) X(0) X(1) X(2) ... X(63) X(0)  (4 EMPTY LOCATIONS)
C
C               AND SO ON.  HERE INC=1, JUMP=70, N=64, M=19, ISIGN=-1,
C               AND FFT99 SHOULD BE USED (BECAUSE OF THE EXPLICIT CYCLIC
C               CONTINUITY). 
C
C               ALTERNATIVELY THE DATA MAY BE ARRANGED LIKE THIS:
C
C                FIRST         SECOND                          LAST
C                DATA          DATA                            DATA
C                VECTOR        VECTOR                          VECTOR
C
C                 A(1)=         A(2)=                           A(19)=
C
C                 X(63)         X(63)       . . .               X(63)
C        A(20)=   X(0)          X(0)        . . .               X(0) 
C        A(39)=   X(1)          X(1)        . . .               X(1) 
C                  .             .                               .
C                  .             .                               .
C                  .             .                               .
C
C               IN WHICH CASE WE HAVE INC=19, JUMP=1, AND THE REMAINING
C               PARAMETERS ARE THE SAME AS BEFORE.  IN EITHER CASE, EACH
C               COEFFICIENT VECTOR OVERWRITES THE CORRESPONDING INPUT
C               DATA VECTOR. 
C
C-----------------------------------------------------------------------
      DIMENSION A(N),WORK(N),TRIGS(N),IFAX(1)
C
C     SUBROUTINE "FFT99" - MULTIPLE FAST REAL PERIODIC TRANSFORM
C     CORRESPONDING TO OLD SCALAR ROUTINE FFT9
C     PROCEDURE USED TO CONVERT TO HALF-LENGTH COMPLEX TRANSFORM
C     IS GIVEN BY COOLEY, LEWIS AND WELCH (J. SOUND VIB., VOL. 12
C     (1970), 315-337)
C
C     A IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA
C     WORK IS AN AREA OF SIZE (N+1)*LOT
C     TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES
C     IFAX IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N/2 
C     INC IS THE INCREMENT WITHIN EACH DATA 'VECTOR'
C         (E.G. INC=1 FOR CONSECUTIVELY STORED DATA)
C     JUMP IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR
C     N IS THE LENGTH OF THE DATA VECTORS
C     LOT IS THE NUMBER OF DATA VECTORS
C     ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT
C           = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL
C
C     ORDERING OF COEFFICIENTS:
C         A(0),B(0),A(1),B(1),A(2),B(2),...,A(N/2),B(N/2)
C         WHERE B(0)=B(N/2)=0; (N+2) LOCATIONS REQUIRED
C
C     ORDERING OF DATA:
C         X(N-1),X(0),X(1),X(2),...,X(N),X(0)
C         I.E. EXPLICIT CYCLIC CONTINUITY; (N+2) LOCATIONS REQUIRED
C
C     VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN
C     PARALLEL
C
C     *** N.B. N IS ASSUMED TO BE AN EVEN NUMBER 
C
C     DEFINITION OF TRANSFORMS:
C     -------------------------
C
C     ISIGN=+1: X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N))
C         WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K)
C
C     ISIGN=-1: A(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*COS(2*J*K*PI/N))
C               B(K)=-(1/N)*SUM(J=0,...,N-1)(X(J)*SIN(2*J*K*PI/N))
C
C
C THE FOLLOWING CALL IS FOR MONITORING LIBRARY USE AT NCAR 
C      CALL Q8QST4 ( 4HXLIB, 6HFFT99F, 5HFFT99, 10HVERSION 01)
      NFAX=IFAX(1) 
      NX=N+1
      NH=N/2
      INK=INC+INC
      IF (ISIGN.EQ.+1) GO TO 30
C
C     IF NECESSARY, TRANSFER DATA TO WORK AREA
      IGO=50
      IF (MOD(NFAX,2).EQ.1) GOTO 40
      IBASE=INC+1
      JBASE=1
      DO 20 L=1,LOT
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 10 M=1,N
      WORK(J)=A(I) 
      I=I+INC
      J=J+1
   10 CONTINUE
      IBASE=IBASE+JUMP
      JBASE=JBASE+NX
   20 CONTINUE
C
      IGO=60
      GO TO 40
C
C     PREPROCESSING (ISIGN=+1)
C     ------------------------
C
   30 CONTINUE
      CALL FFT99A(A,WORK,TRIGS,INC,JUMP,N,LOT)
      IGO=60
C
C     COMPLEX TRANSFORM
C     -----------------
C
   40 CONTINUE
      IA=INC+1
      LA=1
      DO 80 K=1,NFAX
      IF (IGO.EQ.60) GO TO 60
   50 CONTINUE
      CALL VPASSM(A(IA),A(IA+INC),WORK(1),WORK(2),TRIGS,
     *   INK,2,JUMP,NX,LOT,NH,IFAX(K+1),LA)
      IGO=60
      GO TO 70
   60 CONTINUE
      CALL VPASSM(WORK(1),WORK(2),A(IA),A(IA+INC),TRIGS,
     *    2,INK,NX,JUMP,LOT,NH,IFAX(K+1),LA)
      IGO=50
   70 CONTINUE
      LA=LA*IFAX(K+1)
   80 CONTINUE
C
      IF (ISIGN.EQ.-1) GO TO 130
C
C     IF NECESSARY, TRANSFER DATA FROM WORK AREA 
      IF (MOD(NFAX,2).EQ.1) GO TO 110
      IBASE=1
      JBASE=IA
      DO 100 L=1,LOT
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 90 M=1,N
      A(J)=WORK(I) 
      I=I+1
      J=J+INC
   90 CONTINUE
      IBASE=IBASE+NX
      JBASE=JBASE+JUMP
  100 CONTINUE
C
C     FILL IN CYCLIC BOUNDARY POINTS
  110 CONTINUE
      IA=1
      IB=N*INC+1
CDIR$ IVDEP
      DO 120 L=1,LOT
      A(IA)=A(IB)
      A(IB+INC)=A(IA+INC)
      IA=IA+JUMP
      IB=IB+JUMP
  120 CONTINUE
      GO TO 140
C
C     POSTPROCESSING (ISIGN=-1):
C     --------------------------
C
  130 CONTINUE
      CALL FFT99B(WORK,A,TRIGS,INC,JUMP,N,LOT)
C
  140 CONTINUE
      RETURN
      END
      SUBROUTINE FFT99A(A,WORK,TRIGS,INC,JUMP,N,LOT)
      DIMENSION A(N),WORK(N),TRIGS(N)
C
C     SUBROUTINE FFT99A - PREPROCESSING STEP FOR FFT99, ISIGN=+1
C     (SPECTRAL TO GRIDPOINT TRANSFORM)
C
      NH=N/2
      NX=N+1
      INK=INC+INC
C
C     A(0) AND A(N/2)
      IA=1
      IB=N*INC+1
      JA=1
      JB=2
CDIR$ IVDEP
      DO 10 L=1,LOT
      WORK(JA)=A(IA)+A(IB)
      WORK(JB)=A(IA)-A(IB)
      IA=IA+JUMP
      IB=IB+JUMP
      JA=JA+NX
      JB=JB+NX
   10 CONTINUE
C
C     REMAINING WAVENUMBERS
      IABASE=2*INC+1
      IBBASE=(N-2)*INC+1
      JABASE=3
      JBBASE=N-1
C
      DO 30 K=3,NH,2
      IA=IABASE
      IB=IBBASE
      JA=JABASE
      JB=JBBASE
      C=TRIGS(N+K) 
      S=TRIGS(N+K+1)
CDIR$ IVDEP
      DO 20 L=1,LOT
      WORK(JA)=(A(IA)+A(IB))-
     *    (S*(A(IA)-A(IB))+C*(A(IA+INC)+A(IB+INC)))
      WORK(JB)=(A(IA)+A(IB))+
     *    (S*(A(IA)-A(IB))+C*(A(IA+INC)+A(IB+INC)))
      WORK(JA+1)=(C*(A(IA)-A(IB))-S*(A(IA+INC)+A(IB+INC)))+
     *    (A(IA+INC)-A(IB+INC))
      WORK(JB+1)=(C*(A(IA)-A(IB))-S*(A(IA+INC)+A(IB+INC)))-
     *    (A(IA+INC)-A(IB+INC))
      IA=IA+JUMP
      IB=IB+JUMP
      JA=JA+NX
      JB=JB+NX
   20 CONTINUE
      IABASE=IABASE+INK
      IBBASE=IBBASE-INK
      JABASE=JABASE+2
      JBBASE=JBBASE-2
   30 CONTINUE
C
      IF (IABASE.NE.IBBASE) GO TO 50
C     WAVENUMBER N/4 (IF IT EXISTS)
      IA=IABASE
      JA=JABASE
CDIR$ IVDEP
      DO 40 L=1,LOT
      WORK(JA)=2.0*A(IA)
      WORK(JA+1)=-2.0*A(IA+INC)
      IA=IA+JUMP
      JA=JA+NX
   40 CONTINUE
C
   50 CONTINUE
      RETURN
      END
      SUBROUTINE FFT99B(WORK,A,TRIGS,INC,JUMP,N,LOT)
      DIMENSION WORK(N),A(N),TRIGS(N)
C
C     SUBROUTINE FFT99B - POSTPROCESSING STEP FOR FFT99, ISIGN=-1
C     (GRIDPOINT TO SPECTRAL TRANSFORM)
C
      NH=N/2
      NX=N+1
      INK=INC+INC
C
C     A(0) AND A(N/2)
      SCALE=1.0/FLOAT(N)
      IA=1
      IB=2
      JA=1
      JB=N*INC+1
CDIR$ IVDEP
      DO 10 L=1,LOT
      A(JA)=SCALE*(WORK(IA)+WORK(IB))
      A(JB)=SCALE*(WORK(IA)-WORK(IB))
      A(JA+INC)=0.0
      A(JB+INC)=0.0
      IA=IA+NX
      IB=IB+NX
      JA=JA+JUMP
      JB=JB+JUMP
   10 CONTINUE
C
C     REMAINING WAVENUMBERS
      SCALE=0.5*SCALE
      IABASE=3
      IBBASE=N-1
      JABASE=2*INC+1
      JBBASE=(N-2)*INC+1
C
      DO 30 K=3,NH,2
      IA=IABASE
      IB=IBBASE
      JA=JABASE
      JB=JBBASE
      C=TRIGS(N+K) 
      S=TRIGS(N+K+1)
CDIR$ IVDEP
      DO 20 L=1,LOT
      A(JA)=SCALE*((WORK(IA)+WORK(IB)) 
     *   +(C*(WORK(IA+1)+WORK(IB+1))+S*(WORK(IA)-WORK(IB))))
      A(JB)=SCALE*((WORK(IA)+WORK(IB)) 
     *   -(C*(WORK(IA+1)+WORK(IB+1))+S*(WORK(IA)-WORK(IB))))
      A(JA+INC)=SCALE*((C*(WORK(IA)-WORK(IB))-S*(WORK(IA+1)+WORK(IB+1)))
     *    +(WORK(IB+1)-WORK(IA+1)))
      A(JB+INC)=SCALE*((C*(WORK(IA)-WORK(IB))-S*(WORK(IA+1)+WORK(IB+1)))
     *    -(WORK(IB+1)-WORK(IA+1)))
      IA=IA+NX
      IB=IB+NX
      JA=JA+JUMP
      JB=JB+JUMP
   20 CONTINUE
      IABASE=IABASE+2
      IBBASE=IBBASE-2
      JABASE=JABASE+INK
      JBBASE=JBBASE-INK
   30 CONTINUE
C
      IF (IABASE.NE.IBBASE) GO TO 50
C     WAVENUMBER N/4 (IF IT EXISTS)
      IA=IABASE
      JA=JABASE
      SCALE=2.0*SCALE
CDIR$ IVDEP
      DO 40 L=1,LOT
      A(JA)=SCALE*WORK(IA)
      A(JA+INC)=-SCALE*WORK(IA+1)
      IA=IA+NX
      JA=JA+JUMP
   40 CONTINUE
C
   50 CONTINUE
      RETURN
      END
      SUBROUTINE FFT991(A,WORK,TRIGS,IFAX,INC,JUMP,N,LOT,ISIGN)
      DIMENSION A(N),WORK(N),TRIGS(N),IFAX(1)
C
C     SUBROUTINE "FFT991" - MULTIPLE REAL/HALF-COMPLEX PERIODIC
C     FAST FOURIER TRANSFORM 
C
C     SAME AS FFT99 EXCEPT THAT ORDERING OF DATA CORRESPONDS TO
C     THAT IN MRFFT2
C
C     PROCEDURE USED TO CONVERT TO HALF-LENGTH COMPLEX TRANSFORM
C     IS GIVEN BY COOLEY, LEWIS AND WELCH (J. SOUND VIB., VOL. 12
C     (1970), 315-337)
C
C     A IS THE ARRAY CONTAINING INPUT AND OUTPUT DATA
C     WORK IS AN AREA OF SIZE (N+1)*LOT
C     TRIGS IS A PREVIOUSLY PREPARED LIST OF TRIG FUNCTION VALUES
C     IFAX IS A PREVIOUSLY PREPARED LIST OF FACTORS OF N/2 
C     INC IS THE INCREMENT WITHIN EACH DATA 'VECTOR'
C         (E.G. INC=1 FOR CONSECUTIVELY STORED DATA)
C     JUMP IS THE INCREMENT BETWEEN THE START OF EACH DATA VECTOR
C     N IS THE LENGTH OF THE DATA VECTORS
C     LOT IS THE NUMBER OF DATA VECTORS
C     ISIGN = +1 FOR TRANSFORM FROM SPECTRAL TO GRIDPOINT
C           = -1 FOR TRANSFORM FROM GRIDPOINT TO SPECTRAL
C
C     ORDERING OF COEFFICIENTS:
C         A(0),B(0),A(1),B(1),A(2),B(2),...,A(N/2),B(N/2)
C         WHERE B(0)=B(N/2)=0; (N+2) LOCATIONS REQUIRED
C
C     ORDERING OF DATA:
C         X(0),X(1),X(2),...,X(N-1)
C
C     VECTORIZATION IS ACHIEVED ON CRAY BY DOING THE TRANSFORMS IN
C     PARALLEL
C
C     *** N.B. N IS ASSUMED TO BE AN EVEN NUMBER 
C
C     DEFINITION OF TRANSFORMS:
C     -------------------------
C
C     ISIGN=+1: X(J)=SUM(K=0,...,N-1)(C(K)*EXP(2*I*J*K*PI/N))
C         WHERE C(K)=A(K)+I*B(K) AND C(N-K)=A(K)-I*B(K)
C
C     ISIGN=-1: A(K)=(1/N)*SUM(J=0,...,N-1)(X(J)*COS(2*J*K*PI/N))
C               B(K)=-(1/N)*SUM(J=0,...,N-1)(X(J)*SIN(2*J*K*PI/N))
C
C THE FOLLOWING CALL IS FOR MONITORING LIBRARY USE AT NCAR 
C      CALL Q8QST4 ( 4HXLIB, 6HFFT99F, 6HFFT991, 10HVERSION 01)
      NFAX=IFAX(1) 
      NX=N+1
      NH=N/2
      INK=INC+INC
      IF (ISIGN.EQ.+1) GO TO 30
C
C     IF NECESSARY, TRANSFER DATA TO WORK AREA
      IGO=50
      IF (MOD(NFAX,2).EQ.1) GOTO 40
      IBASE=1
      JBASE=1
      DO 20 L=1,LOT
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 10 M=1,N
      WORK(J)=A(I) 
      I=I+INC
      J=J+1
   10 CONTINUE
      IBASE=IBASE+JUMP
      JBASE=JBASE+NX
   20 CONTINUE
C
      IGO=60
      GO TO 40
C
C     PREPROCESSING (ISIGN=+1)
C     ------------------------
C
   30 CONTINUE
      CALL FFT99A(A,WORK,TRIGS,INC,JUMP,N,LOT)
      IGO=60
C
C     COMPLEX TRANSFORM
C     -----------------
C
   40 CONTINUE
      IA=1
      LA=1
      DO 80 K=1,NFAX
      IF (IGO.EQ.60) GO TO 60
   50 CONTINUE
      CALL VPASSM(A(IA),A(IA+INC),WORK(1),WORK(2),TRIGS,
     *   INK,2,JUMP,NX,LOT,NH,IFAX(K+1),LA)
      IGO=60
      GO TO 70
   60 CONTINUE
      CALL VPASSM(WORK(1),WORK(2),A(IA),A(IA+INC),TRIGS,
     *    2,INK,NX,JUMP,LOT,NH,IFAX(K+1),LA)
      IGO=50
   70 CONTINUE
      LA=LA*IFAX(K+1)
   80 CONTINUE
C
      IF (ISIGN.EQ.-1) GO TO 130
C
C     IF NECESSARY, TRANSFER DATA FROM WORK AREA 
      IF (MOD(NFAX,2).EQ.1) GO TO 110
      IBASE=1
      JBASE=1
      DO 100 L=1,LOT
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 90 M=1,N
      A(J)=WORK(I) 
      I=I+1
      J=J+INC
   90 CONTINUE
      IBASE=IBASE+NX
      JBASE=JBASE+JUMP
  100 CONTINUE
C
C     FILL IN ZEROS AT END
  110 CONTINUE
      IB=N*INC+1
CDIR$ IVDEP
      DO 120 L=1,LOT
      A(IB)=0.0
      A(IB+INC)=0.0
      IB=IB+JUMP
  120 CONTINUE
      GO TO 140
C
C     POSTPROCESSING (ISIGN=-1):
C     --------------------------
C
  130 CONTINUE
      CALL FFT99B(WORK,A,TRIGS,INC,JUMP,N,LOT)
C
  140 CONTINUE
      RETURN
      END
      SUBROUTINE FFTFAX(N,IFAX,TRIGS)
      DIMENSION IFAX(13),TRIGS(1)
C
C MODE 3 IS USED FOR REAL/HALF-COMPLEX TRANSFORMS.  IT IS POSSIBLE
C TO DO COMPLEX/COMPLEX TRANSFORMS WITH OTHER VALUES OF MODE, BUT
C DOCUMENTATION OF THE DETAILS WERE NOT AVAILABLE WHEN THIS ROUTINE
C WAS WRITTEN.
C
      DATA MODE /3/
      CALL FAX (IFAX, N, MODE)
      I = IFAX(1)
      IF (IFAX(I+1) .GT. 5 .OR. N .LE. 4) IFAX(1) = -99
C     IF (IFAX(1) .LE. 0 )CALL ULIBER(33, ' FFTFAX -- INVALID N', 20)
      CALL FFTRIG (TRIGS, N, MODE)
      RETURN
      END
      SUBROUTINE FAX(IFAX,N,MODE)
      DIMENSION IFAX(10)
      NN=N
      IF (IABS(MODE).EQ.1) GO TO 10
      IF (IABS(MODE).EQ.8) GO TO 10
      NN=N/2
      IF ((NN+NN).EQ.N) GO TO 10
      IFAX(1)=-99
      RETURN
   10 K=1
C     TEST FOR FACTORS OF 4
   20 IF (MOD(NN,4).NE.0) GO TO 30
      K=K+1
      IFAX(K)=4
      NN=NN/4
      IF (NN.EQ.1) GO TO 80
      GO TO 20
C     TEST FOR EXTRA FACTOR OF 2
   30 IF (MOD(NN,2).NE.0) GO TO 40
      K=K+1
      IFAX(K)=2
      NN=NN/2
      IF (NN.EQ.1) GO TO 80
C     TEST FOR FACTORS OF 3
   40 IF (MOD(NN,3).NE.0) GO TO 50
      K=K+1
      IFAX(K)=3
      NN=NN/3
      IF (NN.EQ.1) GO TO 80
      GO TO 40
C     NOW FIND REMAINING FACTORS
   50 L=5
      INC=2
C     INC ALTERNATELY TAKES ON VALUES 2 AND 4
   60 IF (MOD(NN,L).NE.0) GO TO 70
      K=K+1
      IFAX(K)=L
      NN=NN/L
      IF (NN.EQ.1) GO TO 80
      GO TO 60
   70 L=L+INC
      INC=6-INC
      GO TO 60
   80 IFAX(1)=K-1
C     IFAX(1) CONTAINS NUMBER OF FACTORS
      NFAX=IFAX(1) 
C     SORT FACTORS INTO ASCENDING ORDER
      IF (NFAX.EQ.1) GO TO 110
      DO 100 II=2,NFAX
      ISTOP=NFAX+2-II
      DO 90 I=2,ISTOP
      IF (IFAX(I+1).GE.IFAX(I)) GO TO 90
      ITEM=IFAX(I) 
      IFAX(I)=IFAX(I+1)
      IFAX(I+1)=ITEM
   90 CONTINUE
  100 CONTINUE
  110 CONTINUE
      RETURN
      END
      SUBROUTINE FFTRIG(TRIGS,N,MODE)
      DIMENSION TRIGS(1)
      PI=2.0*ASIN(1.0)
      IMODE=IABS(MODE)
      NN=N
      IF (IMODE.GT.1.AND.IMODE.LT.6) NN=N/2
      DEL=(PI+PI)/FLOAT(NN)
      L=NN+NN
      DO 10 I=1,L,2
      ANGLE=0.5*FLOAT(I-1)*DEL
      TRIGS(I)=COS(ANGLE)
      TRIGS(I+1)=SIN(ANGLE)
   10 CONTINUE
      IF (IMODE.EQ.1) RETURN 
      IF (IMODE.EQ.8) RETURN 
      DEL=0.5*DEL
      NH=(NN+1)/2
      L=NH+NH
      LA=NN+NN
      DO 20 I=1,L,2
      ANGLE=0.5*FLOAT(I-1)*DEL
      TRIGS(LA+I)=COS(ANGLE) 
      TRIGS(LA+I+1)=SIN(ANGLE)
   20 CONTINUE
      IF (IMODE.LE.3) RETURN 
      DEL=0.5*DEL
      LA=LA+NN
      IF (MODE.EQ.5) GO TO 40
      DO 30 I=2,NN 
      ANGLE=FLOAT(I-1)*DEL
      TRIGS(LA+I)=2.0*SIN(ANGLE)
   30 CONTINUE
      RETURN
   40 CONTINUE
      DEL=0.5*DEL
      DO 50 I=2,N
      ANGLE=FLOAT(I-1)*DEL
      TRIGS(LA+I)=SIN(ANGLE) 
   50 CONTINUE
      RETURN
      END
      SUBROUTINE VPASSM(A,B,C,D,TRIGS,INC1,INC2,INC3,INC4,LOT,N,IFAC,LA)
      DIMENSION A(N),B(N),C(N),D(N),TRIGS(N)
C
C     SUBROUTINE "VPASSM" - MULTIPLE VERSION OF "VPASSA"
C     PERFORMS ONE PASS THROUGH DATA
C     AS PART OF MULTIPLE COMPLEX FFT ROUTINE
C     A IS FIRST REAL INPUT VECTOR
C     B IS FIRST IMAGINARY INPUT VECTOR
C     C IS FIRST REAL OUTPUT VECTOR
C     D IS FIRST IMAGINARY OUTPUT VECTOR
C     TRIGS IS PRECALCULATED TABLE OF SINES " COSINES
C     INC1 IS ADDRESSING INCREMENT FOR A AND B
C     INC2 IS ADDRESSING INCREMENT FOR C AND D
C     INC3 IS ADDRESSING INCREMENT BETWEEN A"S & B"S
C     INC4 IS ADDRESSING INCREMENT BETWEEN C"S & D"S
C     LOT IS THE NUMBER OF VECTORS
C     N IS LENGTH OF VECTORS 
C     IFAC IS CURRENT FACTOR OF N
C     LA IS PRODUCT OF PREVIOUS FACTORS
C
      DATA SIN36/0.587785252292473/,COS36/0.809016994374947/,
     *     SIN72/0.951056516295154/,COS72/0.309016994374947/,
     *     SIN60/0.866025403784437/
C
      M=N/IFAC
      IINK=M*INC1
      JINK=LA*INC2 
      JUMP=(IFAC-1)*JINK
      IBASE=0
      JBASE=0
      IGO=IFAC-1
      IF (IGO.GT.4) RETURN
      GO TO (10,50,90,130),IGO
C
C     CODING FOR FACTOR 2
C
   10 IA=1
      JA=1
      IB=IA+IINK
      JB=JA+JINK
      DO 20 L=1,LA 
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 15 IJK=1,LOT
      C(JA+J)=A(IA+I)+A(IB+I)
      D(JA+J)=B(IA+I)+B(IB+I)
      C(JB+J)=A(IA+I)-A(IB+I)
      D(JB+J)=B(IA+I)-B(IB+I)
      I=I+INC3
      J=J+INC4
   15 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
   20 CONTINUE
      IF (LA.EQ.M) RETURN
      LA1=LA+1
      JBASE=JBASE+JUMP
      DO 40 K=LA1,M,LA
      KB=K+K-2
      C1=TRIGS(KB+1)
      S1=TRIGS(KB+2)
      DO 30 L=1,LA 
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 25 IJK=1,LOT
      C(JA+J)=A(IA+I)+A(IB+I)
      D(JA+J)=B(IA+I)+B(IB+I)
      C(JB+J)=C1*(A(IA+I)-A(IB+I))-S1*(B(IA+I)-B(IB+I))
      D(JB+J)=S1*(A(IA+I)-A(IB+I))+C1*(B(IA+I)-B(IB+I))
      I=I+INC3
      J=J+INC4
   25 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
   30 CONTINUE
      JBASE=JBASE+JUMP
   40 CONTINUE
      RETURN
C
C     CODING FOR FACTOR 3
C
   50 IA=1
      JA=1
      IB=IA+IINK
      JB=JA+JINK
      IC=IB+IINK
      JC=JB+JINK
      DO 60 L=1,LA 
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 55 IJK=1,LOT
      C(JA+J)=A(IA+I)+(A(IB+I)+A(IC+I))
      D(JA+J)=B(IA+I)+(B(IB+I)+B(IC+I))
      C(JB+J)=(A(IA+I)-0.5*(A(IB+I)+A(IC+I)))-(SIN60*(B(IB+I)-B(IC+I)))
      C(JC+J)=(A(IA+I)-0.5*(A(IB+I)+A(IC+I)))+(SIN60*(B(IB+I)-B(IC+I)))
      D(JB+J)=(B(IA+I)-0.5*(B(IB+I)+B(IC+I)))+(SIN60*(A(IB+I)-A(IC+I)))
      D(JC+J)=(B(IA+I)-0.5*(B(IB+I)+B(IC+I)))-(SIN60*(A(IB+I)-A(IC+I)))
      I=I+INC3
      J=J+INC4
   55 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
   60 CONTINUE
      IF (LA.EQ.M) RETURN
      LA1=LA+1
      JBASE=JBASE+JUMP
      DO 80 K=LA1,M,LA
      KB=K+K-2
      KC=KB+KB
      C1=TRIGS(KB+1)
      S1=TRIGS(KB+2)
      C2=TRIGS(KC+1)
      S2=TRIGS(KC+2)
      DO 70 L=1,LA 
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 65 IJK=1,LOT
      C(JA+J)=A(IA+I)+(A(IB+I)+A(IC+I))
      D(JA+J)=B(IA+I)+(B(IB+I)+B(IC+I))
      C(JB+J)=
     *    C1*((A(IA+I)-0.5*(A(IB+I)+A(IC+I)))-(SIN60*(B(IB+I)-B(IC+I))))
     *   -S1*((B(IA+I)-0.5*(B(IB+I)+B(IC+I)))+(SIN60*(A(IB+I)-A(IC+I))))
      D(JB+J)=
     *    S1*((A(IA+I)-0.5*(A(IB+I)+A(IC+I)))-(SIN60*(B(IB+I)-B(IC+I))))
     *   +C1*((B(IA+I)-0.5*(B(IB+I)+B(IC+I)))+(SIN60*(A(IB+I)-A(IC+I))))
      C(JC+J)=
     *    C2*((A(IA+I)-0.5*(A(IB+I)+A(IC+I)))+(SIN60*(B(IB+I)-B(IC+I))))
     *   -S2*((B(IA+I)-0.5*(B(IB+I)+B(IC+I)))-(SIN60*(A(IB+I)-A(IC+I))))
      D(JC+J)=
     *    S2*((A(IA+I)-0.5*(A(IB+I)+A(IC+I)))+(SIN60*(B(IB+I)-B(IC+I))))
     *   +C2*((B(IA+I)-0.5*(B(IB+I)+B(IC+I)))-(SIN60*(A(IB+I)-A(IC+I))))
      I=I+INC3
      J=J+INC4
   65 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
   70 CONTINUE
      JBASE=JBASE+JUMP
   80 CONTINUE
      RETURN
C
C     CODING FOR FACTOR 4
C
   90 IA=1
      JA=1
      IB=IA+IINK
      JB=JA+JINK
      IC=IB+IINK
      JC=JB+JINK
      ID=IC+IINK
      JD=JC+JINK
      DO 100 L=1,LA
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 95 IJK=1,LOT
      C(JA+J)=(A(IA+I)+A(IC+I))+(A(IB+I)+A(ID+I))
      C(JC+J)=(A(IA+I)+A(IC+I))-(A(IB+I)+A(ID+I))
      D(JA+J)=(B(IA+I)+B(IC+I))+(B(IB+I)+B(ID+I))
      D(JC+J)=(B(IA+I)+B(IC+I))-(B(IB+I)+B(ID+I))
      C(JB+J)=(A(IA+I)-A(IC+I))-(B(IB+I)-B(ID+I))
      C(JD+J)=(A(IA+I)-A(IC+I))+(B(IB+I)-B(ID+I))
      D(JB+J)=(B(IA+I)-B(IC+I))+(A(IB+I)-A(ID+I))
      D(JD+J)=(B(IA+I)-B(IC+I))-(A(IB+I)-A(ID+I))
      I=I+INC3
      J=J+INC4
   95 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
  100 CONTINUE
      IF (LA.EQ.M) RETURN
      LA1=LA+1
      JBASE=JBASE+JUMP
      DO 120 K=LA1,M,LA
      KB=K+K-2
      KC=KB+KB
      KD=KC+KB
      C1=TRIGS(KB+1)
      S1=TRIGS(KB+2)
      C2=TRIGS(KC+1)
      S2=TRIGS(KC+2)
      C3=TRIGS(KD+1)
      S3=TRIGS(KD+2)
      DO 110 L=1,LA
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 105 IJK=1,LOT
      C(JA+J)=(A(IA+I)+A(IC+I))+(A(IB+I)+A(ID+I))
      D(JA+J)=(B(IA+I)+B(IC+I))+(B(IB+I)+B(ID+I))
      C(JC+J)=
     *    C2*((A(IA+I)+A(IC+I))-(A(IB+I)+A(ID+I)))
     *   -S2*((B(IA+I)+B(IC+I))-(B(IB+I)+B(ID+I)))
      D(JC+J)=
     *    S2*((A(IA+I)+A(IC+I))-(A(IB+I)+A(ID+I)))
     *   +C2*((B(IA+I)+B(IC+I))-(B(IB+I)+B(ID+I)))
      C(JB+J)=
     *    C1*((A(IA+I)-A(IC+I))-(B(IB+I)-B(ID+I)))
     *   -S1*((B(IA+I)-B(IC+I))+(A(IB+I)-A(ID+I)))
      D(JB+J)=
     *    S1*((A(IA+I)-A(IC+I))-(B(IB+I)-B(ID+I)))
     *   +C1*((B(IA+I)-B(IC+I))+(A(IB+I)-A(ID+I)))
      C(JD+J)=
     *    C3*((A(IA+I)-A(IC+I))+(B(IB+I)-B(ID+I)))
     *   -S3*((B(IA+I)-B(IC+I))-(A(IB+I)-A(ID+I)))
      D(JD+J)=
     *    S3*((A(IA+I)-A(IC+I))+(B(IB+I)-B(ID+I)))
     *   +C3*((B(IA+I)-B(IC+I))-(A(IB+I)-A(ID+I)))
      I=I+INC3
      J=J+INC4
  105 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
  110 CONTINUE
      JBASE=JBASE+JUMP
  120 CONTINUE
      RETURN
C
C     CODING FOR FACTOR 5
C
  130 IA=1
      JA=1
      IB=IA+IINK
      JB=JA+JINK
      IC=IB+IINK
      JC=JB+JINK
      ID=IC+IINK
      JD=JC+JINK
      IE=ID+IINK
      JE=JD+JINK
      DO 140 L=1,LA
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 135 IJK=1,LOT
      C(JA+J)=A(IA+I)+(A(IB+I)+A(IE+I))+(A(IC+I)+A(ID+I))
      D(JA+J)=B(IA+I)+(B(IB+I)+B(IE+I))+(B(IC+I)+B(ID+I))
      C(JB+J)=(A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *  -(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))) 
      C(JE+J)=(A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *  +(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))) 
      D(JB+J)=(B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *  +(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))) 
      D(JE+J)=(B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *  -(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))) 
      C(JC+J)=(A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *  -(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))) 
      C(JD+J)=(A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *  +(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))) 
      D(JC+J)=(B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *  +(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))) 
      D(JD+J)=(B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *  -(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))) 
      I=I+INC3
      J=J+INC4
  135 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
  140 CONTINUE
      IF (LA.EQ.M) RETURN
      LA1=LA+1
      JBASE=JBASE+JUMP
      DO 160 K=LA1,M,LA
      KB=K+K-2
      KC=KB+KB
      KD=KC+KB
      KE=KD+KB
      C1=TRIGS(KB+1)
      S1=TRIGS(KB+2)
      C2=TRIGS(KC+1)
      S2=TRIGS(KC+2)
      C3=TRIGS(KD+1)
      S3=TRIGS(KD+2)
      C4=TRIGS(KE+1)
      S4=TRIGS(KE+2)
      DO 150 L=1,LA
      I=IBASE
      J=JBASE
CDIR$ IVDEP
      DO 145 IJK=1,LOT
      C(JA+J)=A(IA+I)+(A(IB+I)+A(IE+I))+(A(IC+I)+A(ID+I))
      D(JA+J)=B(IA+I)+(B(IB+I)+B(IE+I))+(B(IC+I)+B(ID+I))
      C(JB+J)=
     *    C1*((A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *      -(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))))
     *   -S1*((B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *      +(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))))
      D(JB+J)=
     *    S1*((A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *      -(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))))
     *   +C1*((B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *      +(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))))
      C(JE+J)=
     *    C4*((A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *      +(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))))
     *   -S4*((B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *      -(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))))
      D(JE+J)=
     *    S4*((A(IA+I)+COS72*(A(IB+I)+A(IE+I))-COS36*(A(IC+I)+A(ID+I)))
     *      +(SIN72*(B(IB+I)-B(IE+I))+SIN36*(B(IC+I)-B(ID+I))))
     *   +C4*((B(IA+I)+COS72*(B(IB+I)+B(IE+I))-COS36*(B(IC+I)+B(ID+I)))
     *      -(SIN72*(A(IB+I)-A(IE+I))+SIN36*(A(IC+I)-A(ID+I))))
      C(JC+J)=
     *    C2*((A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *      -(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))))
     *   -S2*((B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *      +(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))))
      D(JC+J)=
     *    S2*((A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *      -(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))))
     *   +C2*((B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *      +(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))))
      C(JD+J)=
     *    C3*((A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *      +(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))))
     *   -S3*((B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *      -(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))))
      D(JD+J)=
     *    S3*((A(IA+I)-COS36*(A(IB+I)+A(IE+I))+COS72*(A(IC+I)+A(ID+I)))
     *      +(SIN36*(B(IB+I)-B(IE+I))-SIN72*(B(IC+I)-B(ID+I))))
     *   +C3*((B(IA+I)-COS36*(B(IB+I)+B(IE+I))+COS72*(B(IC+I)+B(ID+I)))
     *      -(SIN36*(A(IB+I)-A(IE+I))-SIN72*(A(IC+I)-A(ID+I))))
      I=I+INC3
      J=J+INC4
  145 CONTINUE
      IBASE=IBASE+INC1
      JBASE=JBASE+INC2
  150 CONTINUE
      JBASE=JBASE+JUMP
  160 CONTINUE
      RETURN
      END
  
CDIR$ NOLIST
      BLOCK DATA CTPACK
C
C   ***************** CHEBYSHEV TRANSFORM PACKAGE *****************
C                    VERSION 1.00  (25 MARCH 1986)
C
C   PURPOSE
C
C       THIS PACKAGE CONTAINS SEVERAL ROUTINES FOR COMPUTING
C       CHEBYSHEV TRANSFORMS AND PERFORMING VARIOUS OPERATIONS
C       ON FUNCTIONS REPRESENTED BY TRUNCATED CHEBYSHEV SERIES.
C
C   DEFINITIONS
C
C           THE CONTINUOUS CHEBYSHEV TRANSFORM PAIR FOR A FUNCTION
C       U(X)  DEFINED ON AN  X-INTERVAL  (A,B)  IS
C
C           U(X)    = SUM (K=0 TO N) OF UHAT(K)*T-SUB-K(S)             ,
C
C                        2                              U(S)*T-SUB-K(S)
C           UHAT(K) = ------- * INTEGRAL (S=-1 TO 1) OF ---------------,
C                     PI*C(K)                            SQRT(1 - S*S)
C
C       WHERE  S = 2*(X-A)/(B-A) - 1,  T-SUB-K(S)  IS THE CHEBYSHEV
C       PLOYNOMIAL OF DEGREE  K  EVALUATED AT  S,  N  IS THE SPECTRAL
C       TRUNCATION,  C(0) = 2,  AND  C(K) = 1  FOR  K = 1, ..., N.
C       THE CORRESPONDING DISCRETE CHEBYSHEV TRANSFORM PAIR IS
C
C           UBAR(J) = SUM (K=0 TO N) OF UHAT(K)*T-SUB-K(S(J))          ,
C
C                         2                       UBAR(J)*T-SUB-K(S(J))
C           UHAT(K) = ---------*SUM (J=0 TO N) OF ---------------------,
C                     N*CBAR(K)                          CBAR(J)
C
C       WHERE  CBAR(K) = 2  FOR  K = 0  AND  K = N  AND  CBAR(K) = 1 
C       OTHERWISE.  THUS THE NUMBERS  UBAR(J)  ARE VALUES OF  U(X)  AT
C       THE CHEBYSHEV COLLOCATION POINTS  X(J) = S(J)*(B-A)/2 + (B+A)/2,
C       WHERE  S(J) = COS( J*PI/N )  (J=0, ..., N).
C
C   CONTENTS
C
C       *************** CONTINUOUS CHEBYSHEV TRANSFORMS ****************
C       THESE ROUTINES COMPUTE THE CONTINUOUS CHEBYSHEV TRANSFORM PAIR
C       DEFINED ABOVE.  THEY OPERATE ON FUNCTIONS DEFINED AT ARBITRARY
C       POINTS  X.  SINCE THEY DO NOT USE THE FFT ALGORITHM THEY ARE 
C       RELATIVELY SLOW.  HOWEVER, THEY MAY BE USEFUL FOR INITIALIZING
C       CHEBYSHEV SPECTRAL MODELS AND DISPLAYING THEIR SOLUTIONS.  THE
C       ROUTINE NAMES AND ACTIONS ARE: 
C
C           CCTPTS:  COMPUTES A PHYSICAL TO SPECTRAL TRANSFORM
C           CCTSTP:  COMPUTES A SPECTRAL TO PHYSICAL TRANSFORM
C
C       THE USE OF EACH OF THESE ROUTINES IS DESCRIBED IN ITS COMMENTS.
C
C       **************** DISCRETE CHEBYSHEV TRANSFORMS *****************
C       THESE ROUTINES COMPUTE THE DISCRETE CHEBYSHEV TRANSFORM PAIR 
C       DEFINED ABOVE.  THEY OPERATE ON FUNCTIONS DEFINED BY THEIR
C       VALUES AT THE CHEBYSHEV COLLOCATION POINTS  X(J).  THE ROUTINE
C       NAMES AND ACTIONS ARE:
C
C            CTRAN:  COMPUTES A SINGLE CHEBYSHEV TRANSFORM 
C           FCTRAN:  COMPUTES A SINGLE CHEBYSHEV TRANSFORM  (USING FFT)
C           MCTRAN:  COMPUTES MULTIPLE CHEBYSHEV TRANSFORMS IN PARALLEL
C           DCTMAT:  GENERATES THE MATRIX REPRESENTING THE TRANSFORM 
C
C       NOTES:  CTRAN  DOES NOT USE THE FFT ALGORITHM, SO IT CAN BE USED
C       WITH ANY TRUNCATION  N  BUT IS RELATIVELY SLOW.  IN CONTRAST,
C       FCTRAN  COMPUTES THE SAME TRANSFORM USING THE FFT ALGORITHM AND
C       HENCE IS FASTER WHEN  N  IS RELATIVELY LARGE (E.G.,  N.GE.40),
C       BUT THE PRIME FACTORS OF  N  SHOULD BE SMALL.  FOR TRANSFORMS IN
C       PARALLEL,  MCTRAN  USES THE FFT ALGORITHM AND IS VERY FAST, AND
C       REQUIRES THAT  N  HAVE NO PRIME FACTORS OTHER THAN 2, 3, OR 5.
C
C       **************** CHEBYSHEV SPECTRAL OPERATIONS *****************
C       THESE ROUTINES RELATE THE CHEBYSHEV SPECTRAL COEFFICIENTS OF A
C       FUNCTION  U(X)  TO THOSE OF THE SPECIFIED OUTPUT FUNCTION.  FOR
C       EACH OPERATION THERE ARE THREE ROUTINES: 
C
C             SINGLE:  OPERATES ON A SINGLE FUNCTION   U(X)
C           MULTIPLE:  OPERATES ON MULTIPLE FUNCTIONS  U(X)  IN PARALLEL
C             MATRIX:  GENERATES THE MATRIX REPRESENTING THE OPERATION
C
C       THE MATRICES MAY BE USEFUL FOR ANALYSIS OR IN IMPLICIT PROBLEMS,
C       AND CAN ALSO BE USED WITH  MATOP  OR  MMATOP  TO COMPUTE THE 
C       OPERATION (SEE MATRIX OPERATIONS BELOW).  THE OPERATIONS AND 
C       CORRESPONDING ROUTINE NAMES ARE:
C
C         OPERATION         OUTPUT                   ROUTINE NAMES
C           LABEL          FUNCTION             SINGLE  MULTIPLE  MATRIX
C
C            DER    X-DERIVATIVE OF U(X)         CSDER   MCSDER   DERMAT
C            INT    INTEGRAL (A TO X) OF U(X)    CSINT   MCSINT   INTMAT
C            MUL    X TIMES U(X)                 CSMUL   MCSMUL   MULMAT
C            XDU    X TIMES X-DERIVATIVE OF  U   CSXDU   MCSXDU   XDUMAT
C            DXU    X-DERIVATIVE OF (X TIMES U)  CSDXU   MCSDXU   DXUMAT
C
C       NOTE:  FOR THE  INT  AND  MUL  ROUTINES, THE LAST INPUT
C       COEFFICIENT  UHAT(N)  IS ASSUMED ZERO AND IS NOT ACCESSED.
C
C       ********************** MATRIX OPERATIONS ***********************
C       THESE ROUTINES ALLOW THE USER TO COMPUTE A TRANSFORM, OPERATION,
C       OR COMBINATION THEREOF BY APPLYING THE CORRESPONDING MATRIX
C       DIRECTLY.  THE ROUTINE NAMES AND ACTIONS ARE:
C
C            MATOP:  COMPUTES A SINGLE MATRIX OPERATION
C           MMATOP:  COMPUTES MULTIPLE MATRIX OPERATIONS IN PARALLEL 
C           MATPRO:  GENERATES A PRODUCT OF TWO MATRICES
C
C       AN ERROR PRINTING ROUTINE  LIBERR  IS ALSO INCLUDED
C
C   ARGUMENTS COMMON TO MOST ROUTINES
C
C       N       INTEGER SPECTRAL TRUNCATION (INDEX OF LAST MODE)
C
C       A, B    REAL ENDPOINTS OF THE  X-INTERVAL  OF THE TRANSFORM
C
C       U       REAL INPUT VECTOR(S), INTERPRETED AS FOLLOWS:
C               FORWARD  TRANSFORM:  U  CONTAINS PHYS. VALUES  UBAR(J)
C               INVERSE  TRANSFORM:  U  CONTAINS COEFFICIENTS  UHAT(K)
C               SPECTRAL OPERATION:  U  CONTAINS COEFFICIENTS  UHAT(K)
C
C       ITRAN   INTEGER SPECIFYING THE TRANSFORM DESIRED:
C               ITRAN.GT.0    FORWARD TRANSFORM (PHYSICAL TO SPECTRAL)
C               ITRAN.LT.0    INVERSE TRANSFORM (SPECTRAL TO PHYSICAL)
C
C       U OR V  REAL OUTPUT VECTOR(S), INTERPRETED AS FOLLOWS:
C               FORWARD  TRANSFORM:  U  CONTAINS COEFFICIENTS  UHAT(K)
C               INVERSE  TRANSFORM:  U  CONTAINS PHYS. VALUES  UBAR(J)
C               SPECTRAL OPERATION:  U  CONTAINS COEFFICIENTS  UHAT(K)
C
C       ALSO, ANY ARGUMENT BEGINNING WITH  Q  IS A REAL MATRIX WHICH 
C       REPRESENTS A TRANSFORM OR AN OPERATION.  THESE MATRICES ARE
C       DIMENSIONED (0:N,0:N) AND STORED COLUMNWISE, I.E., THE FIRST 
C       INDEX GIVES THE ROW AND THE SECOND INDEX GIVES THE COLUMN.
C
C   ADDITIONAL ARGUMENTS FOR MULTIPLE TRANSFORM/OPERATION ROUTINES
C
C       M       INTEGER NUMBER OF INPUT VECTORS
C
C       INC     INTEGER STORAGE INCREMENT BETWEEN SUCCESSIVE
C               ELEMENTS IN EACH INPUT VECTOR (SEE BELOW)
C
C       JUMP    INTEGER STORAGE INCREMENT BETWEEN CORRESPONDING
C               ELEMENTS OF SUCCESSIVE INPUT VECTORS (SEE BELOW)
C               FOR EFFICIENCY ON THE CRAY-1, ARRANGE THE DATA
C               SO THAT  JUMP  IS NOT A MULTIPLE OF 8.
C
C       IFAX    INTEGER VECTOR OF LENGTH 10 TO HOLD FACTORS OF  N
C
C       TRIG    REAL VECTOR FOR TRIG FACTORS FOR FCTRAN (LENGTH  3*N+18)
C
C       TRIGS   REAL VECTOR FOR TRIG FACTORS FOR MCTRAN (LENGTH  2*N)
C
C       WORK    REAL VECTOR TO BE USED FOR SCRATCH STORAGE 
C                   FOR  MCTRAN:  LENGTH AT LEAST  (N+2)*M 
C                   FOR  MCS...:  LENGTH AT LEAST      3*M 
C
C   STORAGE DEFINITION FOR MULTIPLE TRANSFORM/OPERATION ROUTINES
C
C       THE INPUT AND OUTPUT DATA CONSISTS OF A SET OF  M  VECTORS, EACH
C       CONTAINING  N+1  ELEMENTS PLUS (AT LEAST) ONE ADDITIONAL ELEMENT
C       TO BE USED FOR SCRATCH STORAGE.  THESE VECTORS ARE STORED IN  U
C       WITH STORAGE INCREMENTS  INC  BETWEEN SUCCESSIVE ELEMENTS IN ANY
C       VECTOR AND  JUMP  BETWEEN CORRESPONDING ELEMENTS OF SUCCESSIVE
C       VECTORS.
C            FOR EXAMPLE, CONSIDER THE CALCULATION OF  M = 9  TRANSFORMS
C       OF ORDER  N = 64.  USING  I  TO DENOTE THE INDEX OF THE VALUES
C       OR COEFFICIENTS AS IN THE TRANSFORM DEFINITIONS ABOVE, WITH THE
C       VECTORS STORED COLUMNWISE IN  U  (DIMENSIONED 66 BY 9) AS
C
C                       VECTOR 1   VECTOR 2   ...   VECTOR 9
C
C           I = 0        U( 1,1)    U( 1,2)   ...    U( 1,9)
C
C           I = 1        U( 2,1)    U( 2,2)   ...    U( 2,9)
C
C             .              .          .                . 
C             .              .          .                . 
C             .              .          .                . 
C
C           I = 64       U(65,1)    U(65,2)   ...    U(65,9)
C
C           SCRATCH      U(66,1)    U(66,2)   ...    U(66,9)
C
C       ONE WOULD USE  N = 64, M = 9, INC = 1  AND  JUMP = 66.
C       ALTERNATIVELY, WITH THE SAME DATA STORED ROWWISE IN  U
C       (DIMENSIONED 9 BY 66) AS
C
C                         I = 0      I = 1    ...     I = 64    SCRATCH
C
C           VECTOR 1     U(1,1)     U(1,2)    ...    U(1,65)    U(1,66)
C
C           VECTOR 2     U(2,1)     U(2,2)    ...    U(2,65)    U(2,66)
C
C              .            .          .                .          . 
C              .            .          .                .          . 
C              .            .          .                .          . 
C
C           VECTOR 9     U(9,1)     U(9,2)    ...    U(9,65)    U(9,66)
C
C       ONE WOULD USE  N = 64, M = 9, INC = 9  AND  JUMP = 1.
C
C   REQUIRED ROUTINES (ALL ACCESSED BY DEFAULT ON THE NCAR CRAY-1'S) 
C
C       COSTI     CALLED BY  FCTSET  (SOURCE CODE IN  FFTPACK (LOCLIB))
C       COST      CALLED BY  FCTRAN  (SOURCE CODE IN  FFTPACK (LOCLIB))
C       FFTFAX    CALLED BY  MCTSET  (SOURCE CODE IN  FFT99F  (LOCLIB))
C       FFT991    CALLED BY  MCTRAN  (SOURCE CODE IN  FFT99F  (LOCLIB))
C
C   LANGUAGE    FORTRAN 77
C
C   HISTORY
C
C       WRITTEN IN 1982 BY SCOTT R. FULTON
C       MARCH 1983:  ADDED MULTIPLE TRANSFORMS/OPERATIONS
C       JUNE  1984:  REVISED ALL ROUTINES, ADDED DOMAIN SCALING
C       FEB.  1985:  ADDED THE ROUTINES  FCTSET  AND  FCTRAN
C       AUG.  1985:  STANDARDIZED ARGUMENTS, IMPROVED INDEXING
C       SEP.  1985:  CHANGED  FCTRAN  TO USE  FFTPACK  ROUTINE
C       VERSION 1.00  (MAR 86):  REVISED THE DOCUMENTATION 
C
      END
      SUBROUTINE CCTPTS( N, A, B, UFUN, TOL, WORK, UHAT, IERR )
C
C       CONTINUOUS CHEBYSHEV TRANSFORM--PHYSICAL TO SPECTRAL
C
C   PURPOSE
C
C       GIVEN A FUNCTION  U(X)  DEFINED ON  (A,B)  THIS ROUTINE
C       COMPUTES THE CHEBYSHEV SPECTRAL COEFFICIENTS
C
C                        2                              U(S)*T-SUB-K(S)
C           UHAT(K) = ------- * INTEGRAL (S=-1 TO 1) OF ---------------
C                     PI*C(K)                            SQRT(1 - S*S)
C
C       (K = 0, ..., N),  WHERE  S = 2*(X-A)/(B-A) - 1,  T-SUB-K(S)
C       IS THE CHEBYSHEV POLYNOMIAL OF DEGREE  K  EVALUATED AT  S,
C       C(0) = 2,  AND  C(K) = 1  FOR  K = 1, ..., N.
C
C   ARGUMENTS
C
C       DIMENSION   WORK(0:N), UHAT(0:N)
C
C       INPUT
C
C           N       INDEX OF THE LAST SPECTRAL COEFFICIENT DESIRED
C                   (N  MUST BE NONNEGATIVE)
C
C           A, B    ENDPOINTS OF THE X-INTERVAL OF THE TRANSFORM
C
C           UFUN    REAL-VALUED FUNCTION OF THE ARGUMENT  X  WHICH
C                   EVALUATES THE FUNCTION  U  TO BE TRANSFORMED (MUST
C                   BE DECLARED EXTERNAL IN THE PROGRAM CALLING  CCTPTS)
C
C           TOL     CONVERGENCE TOLERANCE FOR THE SPECTRAL COEFFICIENTS:
C                       TOL.GT.0    USE ABSOLUTE TOLERANCE  TOL
C                       TOL.LT.0    USE RELATIVE TOLERANCE -TOL
C                       TOL.EQ.0    USE ABSOLUTE TOLERANCE  1.0E-10*UMAX
C                                   (UMAX = APPROX. MAX ABS(U) ON (A,B))
C                   AN ABSOLUTE TOLERANCE IS RECOMMENDED (PARTICULARLY
C                   IF SOME COEFFICIENTS ARE ZERO--E.G., IF  U  IS EVEN)
C
C       WORK SPACE 
C
C           WORK    REAL VECTOR OF LENGTH AT LEAST  N+1
C
C       OUTPUT
C
C           UHAT    CHEBYSHEV SPECTRAL COEFFICIENTS DEFINED ABOVE
C
C           IERR    ERROR FLAG (ZERO ON NORMAL RETURN)
C
C   ERROR CONDITIONS
C
C       WARNING  (TRANSFORM COMPUTED BUT SUSPECT)
C
C           IERR.LT.0   THE REQUESTED CONVERGENCE TOLERANCE IS NOT
C                       SATISFIED BY ALL MODES.  IF  IERR = -(N+2),
C                       EACH COEFFICIENT  UHAT(K)  IS DETERMINED AS WELL
C                       AS POSSIBLE GIVEN FINITE PRECISION ARITHMETIC.
C                       OTHERWISE,  MODES  K = 0, ..., -(IERR+2) SATISFY
C                       THE TOLERANCE BUT SOME REMAINING MODES DO NOT.
C
C
C       FATAL  (TRANSFORM NOT COMPUTED)
C
C           IERR = 1    THE X-INTERVAL (A,B) HAS ZERO LENGTH
C
C           IERR = 2    N  IS NEGATIVE 
C
C   METHOD
C
C       THE INTEGRALS ARE APPROXIMATED USING GAUSS-CHEBYSHEV QUADRATURE,
C       INCREASING THE NUMBER OF QUADRATURE POINTS UNTIL THE DIFFERENCE
C       BETWEEN SUCCESSIVE APPROXIMATIONS TO EACH COEFFICIENT  UHAT(K)
C       IS NO MORE THAN THE CONVERGENCE CRITERION SPECIFIED BY  TOL. 
C
C
      INTEGER  N, IERR, J, K, KOK, M, MINC, MMAX, MMIN
      REAL     A, B, TOL, WORK(0:N), UHAT(0:N)
      REAL     DTHETA, FACT, P, PI, Q, RERR, SJ, T(3)
      REAL     UERR, UJ, UMAX, UOLD, UTOL
      LOGICAL  SLOW
C
C   INITIALIZATIONS
C
      IERR = 0
      P = (B + A)/2
      Q = (B - A)/2
      IF ( Q.EQ.0.0 )  THEN
          IERR = 1 
          CALL LIBERR( 'CCTPTS', IERR, 'INTERVAL (A,B) HAS ZERO LENGTH')
      END IF
      IF ( N.LT.0 )  THEN
          IERR = 2 
          CALL LIBERR('CCTPTS',IERR,'TRUNCATION  N  MUST BE AT LEAST 0')
      END IF
      IF ( IERR.NE.0 )  RETURN
      IF ( TOL.GT.0.0 )  UTOL = TOL
      IF ( TOL.EQ.0.0 )  RERR = 1.0E-10
      IF ( TOL.LT.0.0 )  RERR = ABS( TOL )
      PI = ACOS( -1.0 )
      DO 10 K=0,N
   10 UHAT(K) = 0.0
      UMAX = 0.0
      SLOW = .FALSE.
      KOK  = -1
      MMIN = MAX(     N+1 ,  11 )
      MMAX = MAX( 50*(N+1), 101 )
      MINC =                 10
C
C   LOOP ON THE NUMBER OF GAUSS-CHEBYSHEV QUADRATURE POINTS
C
      DO 90 M=MMIN,MMAX,MINC 
C
C       STORE THE PREVIOUS APPROXIMATIONS FOR  UHAT(K)  IN  WORK(K)
C
          DO 20 K=KOK+1,N
          WORK(K) = UHAT(K)
   20     UHAT(K) = 0.0
C
C       COMPUTE NEW APPROXIMATION FOR  UHAT  USING  M  QUADRATURE POINTS
C
          DTHETA = PI/M
          DO 40 J=1,M
              SJ = COS( (J - 0.5)*DTHETA )
              UJ = UFUN( P + Q*SJ )
              UMAX = MAX( UMAX, ABS( UJ ) )
              IF ( 0.GT.KOK )  UHAT(0) = UHAT(0) + UJ
              IF ( N.EQ.0 )  GO TO 40
              IF ( 1.GT.KOK )  UHAT(1) = UHAT(1) + UJ*SJ
              T(2) = 1.0
              T(3) = SJ
              FACT = 2.0*SJ
              DO 30 K=2,N
                  T(1) = T(2)
                  T(2) = T(3)
                  T(3) = FACT*T(2) - T(1)
                  IF ( K.GT.KOK )  UHAT(K) = UHAT(K) + UJ*T(3)
   30         CONTINUE
   40     CONTINUE 
          IF ( 0.GT.KOK )  UHAT(0) = UHAT(0)/M
          FACT = 2.0/M
          DO 50 K=MAX( KOK+1,1 ),N
   50     UHAT(K) = FACT*UHAT(K)
C
C       TEST FOR CONVERGENCE 
C
          IF ( TOL.EQ.0.0 )  UTOL = RERR*UMAX
          IF ( M.EQ.MMIN )  UOLD = -UHAT(KOK+1)
          DO 70 K=KOK+1,N
              UERR = ABS( UHAT(K) - WORK(K) )
              IF ( TOL.LT.0.0 )  UTOL = RERR*ABS( UHAT(K) )
              IF ( UERR.LE.UTOL )  GO TO 60
              IF ( UERR.LE.ABS( UHAT(K) - UOLD ) )  GO TO 80
              IF ( UERR.GE.ABS( UHAT(K) )*0.0001 )  GO TO 80
              SLOW = .TRUE.
   60         KOK  = K
              IF ( K.LT.N )  UOLD = -UHAT(K+1)
   70     CONTINUE 
          IF ( SLOW )  THEN
              IERR = -(N + 2)
              CALL LIBERR( 'CCTPTS', IERR,
     2                 'DESIRED ACCURACY NOT OBTAINED DUE TO ROUNDOFF' )
          END IF
          RETURN
   80     UOLD = WORK(KOK+1) 
   90 CONTINUE
C
C   THE CALCULATION DID NOT CONVERGE FOR  K = KOK+1
C
      IERR = -(KOK + 2)
      CALL LIBERR( 'CCTPTS', IERR, 'CALCULATION DID NOT CONVERGE' )
      RETURN
      END
      SUBROUTINE CCTSTP( NX, X, N, A, B, UHAT, UVAL )
C
C
C       CONTINUOUS CHEBYSHEV TRANSFORM--SPECTRAL TO PHYSICAL
C
C
C   PURPOSE
C
C       GIVEN CHEBYSHEV SPECTRAL COEFFICIENTS  UHAT(K) (K = 0, ..., N)
C       AS DEFINED IN THE SUBROUTINE  CCTPTS, THIS SUBROUTINE EVALUATES
C       THE TRUNCATED CHEBYSHEV SERIES 
C
C           U(X) = SUM (K=0 TO N) OF UHAT(K)*T-SUB-K(S)
C
C       AT USER-SPECIFIED POINTS  X = X(J)  (J=1, ..., NX), WHERE
C       T-SUB-K(S)  IS THE CHEBYSHEV POLYNOMIAL OF DEGREE  K  EVALUATED
C       AT THE POINT  S = 2*(X-A)/(B-A) + 1.
C
C       NOTE:  THIS ROUTINE INVERTS THE ACTION OF THE ROUTINE  CCTPTS.
C
C   ARGUMENTS
C
C       DIMENSION   X(NX), UHAT(0:N), UVAL(NX)
C
C       INPUT
C
C           NX      NUMBER OF  X  POINTS
C
C           X       POINTS AT WHICH  U  IS TO BE EVALUATED 
C
C           N       SPECTRAL TRUNCATION (INDEX OF LAST CHEBYSHEV MODE)
C
C           A, B    ENDPOINTS OF THE X-INTERVAL OF THE TRANSFORM
C
C           UHAT    CHEBYSHEV SPECTRAL COEFFICIENTS OF  U
C
C       OUTPUT
C
C           UVAL    UVAL(J)  CONTAINS THE VALUE  U(X(J))  DEFINED ABOVE
C
C
      INTEGER  NX, N, J, K
      REAL     X(NX), A, B, UHAT(0:N), UVAL(NX), FACT, P, Q, SJ, T(3)
C
      P = (B + A)/2
      Q = (B - A)/2
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'CCTSTP', 0, 'INTERVAL (A,B) HAS ZERO LENGTH' )
          RETURN
      END IF
      IF ( N.LT.0 )  THEN
          CALL LIBERR( 'CCTSTP', 0, 'TRUNCATION  N  MUST BE AT LEAST 0')
          RETURN
      END IF
      DO 20 J=1,NX 
          UVAL(J) = UHAT(0)
          IF ( N.EQ.0 )  GO TO 20
          SJ = (X(J) - P)/Q
          UVAL(J) = UVAL(J) + UHAT(1)*SJ
          T(2) = 1.0
          T(3) = SJ
          FACT = 2.0*SJ
          DO 10 K=2,N
              T(1) = T(2)
              T(2) = T(3)
              T(3) = FACT*T(2) - T(1)
              UVAL(J) = UVAL(J) + UHAT(K)*T(3)
   10     CONTINUE 
   20 CONTINUE
      RETURN
      END
      SUBROUTINE CTSET( N, QCT )
C
C   SETS UP THE ORDER  N  TRANSFORM FOR  CTRAN  (GENERATES MATRIX  QCT)
C
      INTEGER  N
      REAL     QCT(0:N,0:N)
C
      CALL DCTMAT( N, -1, QCT )
      RETURN
      END
      SUBROUTINE CTRAN( N, U, ITRAN, QCT, V )
C
C   COMPUTES A DISCRETE CHEBYSHEV TRANSFORM OF ORDER  N
C
C   FIRST CALL CTSET( N, QCT )  TO SET UP THE TRANSFORM OF ORDER  N
C   THEN  CALL CTRAN( N, U, ITRAN, QCT, V )  TO COMPUTE THE TRANSFORM
C   USE  ITRAN.GT.0  FOR FORWARD TRANSFORM (PHYSICAL TO SPECTRAL)
C        ITRAN.LT.0  FOR INVERSE TRANSFORM (SPECTRAL TO PHYSICAL)
C
      INTEGER  N, ITRAN, J, K
      REAL     U(0:N), QCT(0:N,0:N), V(0:N), FACT
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'CTRAN', 0, 'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      IF ( ITRAN.EQ.0 )  THEN
          CALL LIBERR( 'CTRAN', 0, 'CALLED WITH  ITRAN = 0' )
          RETURN
      END IF
      FACT = 1.0
      IF ( ITRAN.GT.0 )  FACT = 0.5
      DO 10 K=0,N
   10 V(K) = FACT*(U(0)*QCT(0,K) + U(N)*QCT(N,K))
      DO 30 J=1,N-1
          DO 20 K=0,N
   20     V(K) = V(K) + U(J)*QCT(J,K)
   30 CONTINUE
      IF ( ITRAN.LT.0 )  RETURN
      V(0) = V(0)/N
      V(N) = V(N)/N
      FACT = 2.0/N 
      DO 40 K=1,N-1
   40 V(K) = FACT*V(K)
      RETURN
      END
      SUBROUTINE FCTSET( N, TRIG )
C
C   SETS UP THE FACTORS NEEDED BY  FCTRAN  FOR A TRANSFORM OF ORDER  N
C
      INTEGER  N
      REAL     TRIG(3*N+18)
C
      CALL COSTI( N+1, TRIG )
      RETURN
      END
      SUBROUTINE FCTRAN( N, U, ITRAN, TRIG )
C
C   COMPUTES A FAST CHEBYSHEV TRANSFORM OF ORDER  N
C
C   USE
C
C       STEP 1:  CALL  FCTSET( N, TRIG )  TO COMPUTE THE TRIGONOMETRIC
C                FACTORS NEEDED FOR A TRANSFORM OF ORDER  N.
C
C       STEP 2:  CALL  FCTRAN  WITH  ITRAN.NE.0  TO COMPUTE THE DESIRED
C                TRANSFORM (USING TRIG PREVIOUSLY COMPUTED FOR THIS N).
C
C   NOTE 
C
C       EITHER MEMBER OF THREE RELATED TRANSFORM PAIRS MAY BE COMPUTED.
C       THE SIGN OF  ITRAN  SPECIFIES THE TRANSFORM DIRECTION:
C           ITRAN.GT.0    FORWARD TRANSFORM (PHYSICAL TO SPECTRAL)
C           ITRAN.LT.0    INVERSE TRANSFORM (SPECTRAL TO PHYSICAL)
C       THE ABSOLUTE VALUE OF  ITRAN  SPECIFIES THE TRANSFORM PAIR:
C           ITRAN = (+/-) 1:    DISCRETE CHEBYSHEV TRANSFORM PAIR WITH
C                               SPECTRAL COEFFICIENTS  UHAT(K)
C           ITRAN = (+/-) 2:    DISCRETE COSINE TRANSFORM PAIR WITH
C                               SPECTRAL COEFFICIENTS  CBAR(K)*UHAT(K)
C           ITRAN = (+/-) 3:    REAL SYMMETRIC FOURIER TRANSFORM PAIR
C                               WITH COEFFICIENTS  CBAR(K)*UHAT(K)/2 
C
C   REQUIRED ROUTINE
C
C       COST      (ACCESSED BY DEFAULT ON THE NCAR CRAY-1'S)
C
      INTEGER  N, ITRAN
      REAL     U(0:N), TRIG(3*N+18)
      INTEGER  K
      REAL     FACTOR
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'FCTRAN', 0, 'N  TOO SMALL--NO ACTION TAKEN' )
          RETURN
      END IF
      IF ( ABS( ITRAN ).GT.3 )  THEN
          CALL LIBERR( 'FCTRAN', 0, 'ABS( ITRAN ).GT.3  NOT PERMITTED' )
          RETURN
      END IF
      IF ( ITRAN.EQ.0 )  THEN
          CALL LIBERR( 'FCTRAN', 0, 'CALLED WITH  ITRAN = 0' )
          RETURN
      END IF
C
C   CONVERT CHEBYSHEV COEFFICIENTS TO COSINE COEFFICIENTS
C
      IF ( ITRAN.EQ.-1 )  THEN
          U(0) = 2.0*U(0)
          U(N) = 2.0*U(N)
      END IF
C
C   SCALE THE COEFFICIENTS OR VALUES
C
      FACTOR = 0.5 
      IF ( ABS( ITRAN ).EQ.3 )  FACTOR = 1.0
      IF ( ITRAN.GT.0 )  FACTOR = 1.0/(2*N*FACTOR)
      IF ( FACTOR.NE.1.0 )  THEN
          DO 10 K=0,N
   10     U(K) = FACTOR*U(K) 
      END IF
C
C   DO THE REAL SYMMETRIC DISCRETE FOURIER TRANSFORM
C
      CALL COST( N+1, U, TRIG )
C
C   CONVERT COSINE COEFFICIENTS TO CHEBYSHEV COEFFICIENTS
C
      IF ( ITRAN.EQ.+1 )  THEN
          U(0) = 0.5*U(0)
          U(N) = 0.5*U(N)
      END IF
      RETURN
      END
      SUBROUTINE CSDER( N, A, B, U )
C
C   CHEBYSHEV SPECTRAL SPACE CALCULATION OF DERIVATIVE WITH RESPECT TO X
C
      INTEGER  N, K
      REAL     A, B, U(0:N), Q, W1, W2 
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'CSDER', 0, 'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      W2     = U(N)
      U(N)   = 0.0 
      W1     = U(N-1)
      U(N-1) = (2*N)*W2/Q
      DO 10 K=N-1,1,-1
          W2     = W1
          W1     = U(K-1)
          U(K-1) = U(K+1) + (2*K)*W2/Q 
   10 CONTINUE
      U(0) = U(0)/2.0
      RETURN
      END
      SUBROUTINE CSINT( N, A, B, U )
C
C   CHEBYSHEV SPECTRAL SPACE CALCULATION OF INTEGRAL WITH RESPECT TO  X
C
      INTEGER  N, K
      REAL     A, B, U(0:N), Q, QM1K, W1, W2
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'CSINT', 0, 'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      W1   = 2.0*U(0)
      U(0) = Q*(U(0) - U(1)/4.0)
      QM1K = Q
      DO 10 K=1,N-2
          W2   = W1
          W1   = U(K)
          U(K) = Q*(W2 - U(K+1))/(2*K) 
          QM1K = -QM1K
          U(0) = U(0) + QM1K*U(K+1)/(K*(K+2))
   10 CONTINUE
      U(N)   = Q*U(N-1)/(2*N)
      U(N-1) = Q*W1/(2*N-2)
      RETURN
      END
      SUBROUTINE CSMUL( N, A, B, U )
C
C   CHEBYSHEV SPECTRAL SPACE CALCULATION OF MULTIPLICATION BY  X
C
      INTEGER  N, K
      REAL     A, B, U(0:N), P, Q, W1, W2
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'CSMUL', 0, 'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'CSMUL', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = Q/2.0 
      W1   = 2.0*U(0)
      U(0) =   P*U(0) + FACT*U(1)
      DO 10 K=1,N-2
          W2   = W1
          W1   = U(K)
          U(K) = P*U(K) + FACT*(W2 + U(K+1))
   10 CONTINUE
      U(N  ) =            FACT*U(N-1)
      U(N-1) = P*U(N-1) + FACT*W1
      RETURN
      END
      SUBROUTINE CSXDU( N, A, B, U )
C
C   CHEBYSHEV SPECTRAL SPACE CALCULATION OF  X  TIMES THE X-DERIVATIVE
C
      INTEGER  N, K
      REAL     A, B, U(0:N), FACT, P, Q, TEMP1, TEMP2, W1, W2, W3
C
      IF ( N.LT.1 )  THEN
          CALL LIBERR( 'CSXDU', 0, 'TRUNCATION  N  MUST BE AT LEAST  1')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'CSXDU', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = P/Q
      W2   = 0.0
      W3   = N*U(N)
      U(N) = W3
      W1   = 2.0*FACT*W3
      DO 10 K=N-1,1,-1
          TEMP1 = K*U(K)
          U(K)  = TEMP1 + W1 
          TEMP2 = W2 + 2.0*(FACT*TEMP1 + W3)
          W2    = W1
          W1    = TEMP2
          W3    = TEMP1
   10 CONTINUE
      U(0) = W1/2.0
      RETURN
      END
      SUBROUTINE CSDXU( N, A, B, U )
C
C   CHEBYSHEV SPECTRAL SPACE CALCULATION OF X-DERIVATIVE OF  X*U
C
      INTEGER  N, K
      REAL     A, B, U(0:N), FACT, P, Q, TEMP1, TEMP2, W1, W2, W3
C
      IF ( N.LT.1 )  THEN
          CALL LIBERR( 'CSDXU', 0, 'TRUNCATION  N  MUST BE AT LEAST  1')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'CSDXU', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = P/Q
      W2   = 0.0
      W3   = N*U(N)
      U(N) = U(N) + W3
      W1   = 2.0*FACT*W3
      DO 10 K=N-1,1,-1
          TEMP1 = K*U(K)
          U(K)  = U(K) + TEMP1 + W1
          TEMP2 = W2 + 2*(FACT*TEMP1 + W3)
          W2    = W1
          W1    = TEMP2
          W3    = TEMP1
   10 CONTINUE
      U(0) = U(0) + W1/2
      RETURN
      END
      SUBROUTINE DCTMAT( N, ITRAN, QDCT )
C
C   GENERATES MATRIX QDCT REPRESENTING THE DISCRETE CHEBYSHEV TRANSFORM
C
      INTEGER  N, J, K
      REAL     QDCT(0:N,0:N), FACT, PI, SJ
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'DCTMAT', 0, 'N  TOO SMALL--NO ACTION TAKEN' )
          RETURN
      END IF
      IF ( ITRAN.EQ.0 )  THEN
          CALL LIBERR( 'DCTMAT', 0, 'ITRAN = 0  NOT PERMITTED' )
          RETURN
      END IF
      PI = ACOS( -1.0 )
      DO 20 J=0,N
          SJ = COS( J*PI/N ) 
          QDCT(J,0) = 1.0
          QDCT(J,1) = SJ
          FACT = 2.0*SJ
          DO 10 K=2,N
   10     QDCT(J,K) = FACT*QDCT(J,K-1) - QDCT(J,K-2)
   20 CONTINUE
      IF ( ITRAN.LT.0 )  RETURN
      FACT = 2.0/N 
      DO 30 J=0,N
      DO 30 K=0,N
   30 QDCT(J,K) = FACT*QDCT(J,K)
      DO 40 J=0,N
          QDCT(J,0) = 0.5*QDCT(J,0)
          QDCT(J,N) = 0.5*QDCT(J,N)
   40 CONTINUE
      DO 50 K=0,N
          QDCT(0,K) = 0.5*QDCT(0,K)
          QDCT(N,K) = 0.5*QDCT(N,K)
   50 CONTINUE
      RETURN
      END
      SUBROUTINE DERMAT( N, A, B, QDER )
C
C   GENERATES MATRIX QDER REPRESENTING DIFFERENTIATION WITH RESPECT TO X
C
      INTEGER  N, J, K
      REAL     A, B, QDER(0:N,0:N), FACT, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'DERMAT', 0,'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      DO 10 J=0,N
      DO 10 K=0,N
   10 QDER(K,J) = 0.0
      DO 30 K=0,N
          FACT = 1.0/Q
          IF ( K.NE.0 )  FACT = 2.0*FACT
          DO 20 J=K+1,N,2
   20     QDER(K,J) = FACT*J 
   30 CONTINUE
      RETURN
      END
      SUBROUTINE INTMAT( N, A, B, QINT )
C
C   GENERATES MATRIX  QINT  REPRESENTING INTEGRATION WITH RESPECT TO  X
C
      INTEGER  N, J, K
      REAL     A, B, QINT(0:N,0:N), Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'INTMAT', 0,'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      DO 10 J=0,N
      DO 10 K=0,N
   10 QINT(K,J) = 0.0
      QINT(0,0) =  Q
      QINT(0,1) = -Q/4.0
      DO 20 J=2,N-1,2
   20 QINT(0,J) = -Q/(J**2-1)
      DO 30 J=3,N-1,2
   30 QINT(0,J) =  Q/(J**2-1)
      QINT(1,0) =  Q
      DO 40 K=2,N
   40 QINT(K,K-1) =  Q/(2*K) 
      DO 50 K=1,N-2
   50 QINT(K,K+1) = -Q/(2*K) 
      RETURN
      END
      SUBROUTINE MULMAT( N, A, B, QMUL )
C
C   GENERATES THE MATRIX  QMUL  REPRESENTING MULTIPLICATION BY  X
C
      INTEGER  N, J, K
      REAL     A, B, QMUL(0:N,0:N), FACT, P, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'MULMAT', 0,'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'MULMAT', 0, 'INTERVAL (A,B) HAS ZERO LENGTH')
      END IF
      DO 10 J=0,N
      DO 10 K=0,N
   10 QMUL(K,J) = 0.0
      DO 20 K=0,N-1
   20 QMUL(K,K) = P
      QMUL(1,0) = Q
      FACT = Q/2.0 
      DO 30 K=2,N
   30 QMUL(K,K-1) = FACT
      DO 40 K=0,N-2
   40 QMUL(K,K+1) = FACT
      RETURN
      END
      SUBROUTINE XDUMAT( N, A, B, QXDU )
C
C   GENERATES THE MATRIX  QXDU  REPRESENTING  X  TIMES THE X-DERIVATIVE
C
      INTEGER  N, J, K
      REAL     A, B, QXDU(0:N,0:N), FACT, P, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'XDUMAT', 0,'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'XDUMAT', 0, 'INTERVAL (A,B) HAS ZERO LENGTH')
      END IF
      DO 10 J=0,N
      DO 10 K=0,N
   10 QXDU(K,J) = 0.0
      FACT = P/Q
      DO 40 K=0,N
          QXDU(K,K) = K
          DO 20 J=K+1,N,2
   20     QXDU(K,J) = 2*FACT*J
          DO 30 J=K+2,N,2
   30     QXDU(K,J) = 2*J
   40 CONTINUE
      DO 50 J=1,N
   50 QXDU(0,J) = QXDU(0,J)/2.0
      RETURN
      END
      SUBROUTINE DXUMAT( N, A, B, QDXU )
C
C   GENERATES THE MATRIX  QDXU  REPRESENTING THE X-DERIVATIVE OF  X*U
C
      INTEGER  N, J, K
      REAL     A, B, QDXU(0:N,0:N), FACT, P, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'DXUMAT', 0,'TRUNCATION  N  MUST BE AT LEAST  2')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'DXUMAT', 0, 'INTERVAL (A,B) HAS ZERO LENGTH')
      END IF
      DO 10 J=0,N
      DO 10 K=0,N
   10 QDXU(K,J) = 0.0
      FACT = P/Q
      DO 40 K=0,N
          QDXU(K,K) = K+1
          DO 20 J=K+1,N,2
   20     QDXU(K,J) = 2*FACT*J
          DO 30 J=K+2,N,2
   30     QDXU(K,J) = 2*J
   40 CONTINUE
      DO 50 J=1,N
   50 QDXU(0,J) = QDXU(0,J)/2.0
      RETURN
      END
      SUBROUTINE MCTSET( N, IFAX, TRIGS )
C
C   SETS UP THE FACTORS NEEDED BY  MCTRAN  FOR A TRANSFORM OF ORDER  N
C
      INTEGER  N, IFAX(10), J, NTFFT
      REAL     TRIGS(2*N), FACTOR
C
      NTFFT = 3*N/2 + 1
      CALL FFTFAX( N, IFAX, TRIGS )
      FACTOR = ACOS( -1.0 )/N
      DO 10 J=1,N/2-1
   10 TRIGS(NTFFT+J) = 0.5/SIN( J*FACTOR )
      RETURN
      END
      SUBROUTINE MCTRANF( N, U, ITRAN, M, INC, JUMP, IFAX, TRIGS, WORK )
C
C   COMPUTES MULTIPLE DISCRETE CHEBYSHEV TRANSFORMS OF ORDER  N
C
C   USE
C
C       STEP 1:  CALL  MCTSET( N, IFAX, TRIGS )  TO COMPUTE THE
C                FACTORIZATION (IFAX) AND TRIGONOMETRIC FACTORS
C                (TRIGS) NEEDED FOR A TRANSFORM OF ORDER  N.
C
C       STEP 2:  CALL  MCTRAN  WITH  ITRAN.NE.0  TO COMPUTE THE
C                DESIRED TRANSFORMS (USING  IFAX  AND  TRIGS
C                PREVIOUSLY COMPUTED FOR THIS  N  IN STEP 1).
C
C   NOTE 
C
C       EITHER MEMBER OF THREE RELATED TRANSFORM PAIRS MAY BE COMPUTED.
C       THE SIGN OF  ITRAN  SPECIFIES THE TRANSFORM DIRECTION:
C           ITRAN.GT.0    FORWARD TRANSFORM (PHYSICAL TO SPECTRAL)
C           ITRAN.LT.0    INVERSE TRANSFORM (SPECTRAL TO PHYSICAL)
C       THE ABSOLUTE VALUE OF  ITRAN  SPECIFIES THE TRANSFORM PAIR:
C           ITRAN = (+/-) 1:    DISCRETE CHEBYSHEV TRANSFORM PAIR WITH
C                               SPECTRAL COEFFICIENTS  UHAT(K)
C           ITRAN = (+/-) 2:    DISCRETE COSINE TRANSFORM PAIR WITH
C                               SPECTRAL COEFFICIENTS  CBAR(K)*UHAT(K)
C           ITRAN = (+/-) 3:    REAL SYMMETRIC FOURIER TRANSFORM PAIR
C                               WITH COEFFICIENTS  CBAR(K)*UHAT(K)/2 
C
C   METHOD
C
C       THE TRANSFORMS ARE REDUCED TO HALF-COMPLEX TO REAL DISCRETE
C       FOURIER TRANSFORMS BY THE METHOD OF COOLEY, ET AL., J. SOUND 
C       VIB., VOL. 12, 315-337.  THESE TRANSFORMS ARE COMPUTED USING 
C       THE ROUTINE  FFT991  (ACCESSED BY DEFAULT ON NCAR CRAY-1'S). 
C
      INTEGER  N, M, INC, JUMP, ITRAN, IFAX(10)
      REAL     U(JUMP,*), TRIGS(2*N), WORK(M*(N+2))
      INTEGER  I, IM, IN, IP, I0, J, L, NTFFT
      REAL     FACTOR, FACTRM, TEMP1, TEMP2
C
      IF ( N.LT.4 )  THEN
          CALL LIBERR( 'MCTRAN', 0, 'N  TOO SMALL--NO ACTION TAKEN' )
          RETURN
      END IF
      IF ( ABS( ITRAN ).GT.3 )  THEN
          CALL LIBERR( 'MCTRAN', 0, 'ABS( ITRAN ).GT.3  NOT PERMITTED' )
          RETURN
      END IF
      IF ( ITRAN.EQ.0 )  THEN
          CALL LIBERR( 'MCTRAN', 0, 'CALLED WITH  ITRAN = 0' )
          RETURN
      END IF
C
C ************************** INITIALIZATIONS ***************************
C
C   SET THE SCALING FOR THE COEFFICIENTS
C
      IF ( ITRAN.LT.0 )  THEN
          FACTOR = 0.25
          IF ( ITRAN.EQ.-3 )  FACTOR = 0.5
      ELSE
          FACTOR = 1.0/(2*N) 
          IF ( ITRAN.EQ.+3 )  FACTOR = 1.0/(4*N) 
      END IF
C
C   SET THE INDEXING FOR THE TRIG FACTORS AND THE FIRST AND LAST MODES
C
      NTFFT = 3*N/2 + 1
      I0 = 1
      IN = I0 + N*INC
C
C ********** PREPROCESSING FOR SPECTRAL TO PHYSICAL TRANSFORM **********
C
C   CONVERT CHEBYSHEV COEFFICIENTS TO COSINE COEFFICIENTS
C
      IF ( ITRAN.EQ.-1 )  THEN
          DO 20 L=1,M
              U(I0,L) = 2.0*U(I0,L)
              U(IN,L) = 2.0*U(IN,L)
   20     CONTINUE 
      END IF
C
C *********** FFT  OF REAL SYMMETRIC SEQUENCE OF LENGTH  2N ************
C
C   SUM THE ODD POINTS AND FORM THE CONJUGATE SYMMETRIC SEQUENCE
C
      DO 30 L=1,M
   30 WORK(L) = 0.0
      IP = IN - INC
      IM = IP - 2*INC
      DO 50 J=N-1,3,-2
          DO 40 L=1,M
              WORK(L) = WORK(L) + U(IP,L)
              U(IP,L) = U(IP,L) - U(IM,L)
   40     CONTINUE 
          IP = IM
          IM = IP - 2*INC
   50 CONTINUE
      DO 60 L=1,M
   60 WORK(L) = 2.0*(WORK(L) + U(IP,L))
C
C   DO THE  FFT  OF LENGTH  N
C
      CALL FFT991( U, WORK(M+1), TRIGS, IFAX, INC, JUMP, N, M, +1 )
C
C   COMBINE THE RESULTS TO OBTAIN THE TRANSFORM OF LENGTH  2N
C
      IP = I0 + INC
      IM = IN - INC
      DO 80 J=1,N/2-1
          FACTRM = FACTOR*TRIGS(NTFFT+J)
          DO 70 L=1,M
              TEMP1 = FACTOR*(U(IP,L) + U(IM,L)) 
              TEMP2 = FACTRM*(U(IP,L) - U(IM,L)) 
              U(IP,L) = TEMP1 + TEMP2
              U(IM,L) = TEMP1 - TEMP2
   70     CONTINUE 
          IP = IP + INC
          IM = IM - INC
   80 CONTINUE
      FACTOR = 2.0*FACTOR
      DO 90 L=1,M
          U(IN,L) = FACTOR*(U(I0,L) - WORK(L))
          U(IM,L) = FACTOR* U(IM,L)
          U(I0,L) = FACTOR*(U(I0,L) + WORK(L))
   90 CONTINUE
C
C ********** POSTPROCESSING FOR PHYSICAL TO SPECTRAL TRANSFORM *********
C
C   CONVERT COSINE COEFFICIENTS TO CHEBYSHEV COEFFICIENTS
C
      IF ( ITRAN.EQ.+1 )  THEN
          DO 100 L=1,M
              U(I0,L) = 0.5*U(I0,L)
              U(IN,L) = 0.5*U(IN,L)
  100     CONTINUE 
      END IF
      RETURN
      END
      SUBROUTINE MCSDER( N, A, B, U, M, INC, JUMP, WORK )
C
C   MULTIPLE CHEBYSHEV SPECTRAL SPACE CALCULATION OF DERIVATIVES
C
      INTEGER  N, M, INC, JUMP
      REAL     A, B, U(JUMP,*), WORK(M,2)
      INTEGER  IK, IM, IP, K, L
      REAL     FACT, Q
C
      IF ( N.LT.1 )  THEN
          CALL LIBERR( 'MCSDER', 0,'TRUNCATION  N  MUST BE AT LEAST  1')
          RETURN
      END IF
      IK = 1 + N*INC
      IM = IK - INC
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      FACT = 2*N/Q 
      DO 10 L=1,M
          WORK(L,2) = U(IK,L)
          U(IK,L)   = 0.0
          WORK(L,1) = U(IM,L)
          U(IM,L)   = FACT*WORK(L,2)
   10 CONTINUE
      DO 30 K=N-1,1,-1
          IP = IK
          IK = IM
          IM = IK - INC
          FACT = 2*K/Q
          DO 20 L=1,M
              WORK(L,2) = WORK(L,1)
              WORK(L,1) = U(IM,L)
              U(IM,L) = U(IP,L) + FACT*WORK(L,2) 
   20     CONTINUE 
   30 CONTINUE
      DO 40 L=1,M
   40 U(IM,L) = U(IM,L)/2.0
      RETURN
      END
      SUBROUTINE MCSINT( N, A, B, U, M, INC, JUMP, WORK )
C
C   MULTIPLE CHEBYSHEV SPECTRAL SPACE CALCULATION OF INTEGRALS
C
      INTEGER  N, M, INC, JUMP
      REAL     A, B, U(JUMP,*), WORK(M,2)
      INTEGER  IK, IP, I0, K, L
      REAL     FACT1, FACT2, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'MCSINT', 0, 'TRUNCATION  N  MUST BE AT LEAST 2')
          RETURN
      END IF
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      I0 = 1
      IK = I0
      IP = IK + INC
      DO 10 L=1,M
          WORK(L,1) = 2.0* U(IK,L)
          U(IK,L)   =   Q*(U(IK,L) - 0.25*U(IP,L))
   10 CONTINUE
      DO 30 K=1,N-2
          IK = IP
          IP = IK + INC
          FACT1 = Q/(2*K)
          FACT2 = Q/(K*(K+2))
          IF ( MOD( K, 2 ).NE.0 )  FACT2 = -FACT2
          DO 20 L=1,M
              WORK(L,2) = WORK(L,1)
              WORK(L,1) = U(IK,L)
              U(IK,L) = FACT1*(WORK(L,2) - U(IP,L))
              U(I0,L) = U(I0,L) + FACT2*U(IP,L)
   20     CONTINUE 
   30 CONTINUE
      IK = IP
      IP = IK + INC
      FACT1 = Q/(2*N-2)
      FACT2 = Q/(2*N)
      DO 40 L=1,M
          U(IP,L) = FACT2*U(IK,L)
          U(IK,L) = FACT1*WORK(L,1)
   40 CONTINUE
      RETURN
      END
      SUBROUTINE MCSMUL( N, A, B, U, M, INC, JUMP, WORK )
C
C   MULTIPLE CHEBYSHEV SPECTRAL SPACE CALCULATION OF  X*U
C
      INTEGER  N, M, INC, JUMP
      REAL     A, B, U(JUMP,*), WORK(M,2)
      INTEGER  IK, IP, K, L
      REAL     FACT, P, Q
C
      IF ( N.LT.2 )  THEN
          CALL LIBERR( 'MCSMUL', 0, 'TRUNCATION  N  MUST BE AT LEAST 2')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'MSMUL', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = Q/2.0 
      IK = 1
      IP = IK + INC
      DO 10 L=1,M
          WORK(L,1) = 2.0*U(IK,L)
          U(IK,L)   = P*U(IK,L) + FACT*U(IP,L)
   10 CONTINUE
      DO 30 K=1,N-2
          IK = IP
          IP = IK + INC
          DO 20 L=1,M
              WORK(L,2) = WORK(L,1)
              WORK(L,1) = U(IK,L)
              U(IK,L)   = P*U(IK,L) + FACT*(WORK(L,2) + U(IP,L))
   20     CONTINUE 
   30 CONTINUE
      IK = IP
      IP = IK + INC
      DO 40 L=1,M
          U(IP,L) =             FACT*U(IK,L)
          U(IK,L) = P*U(IK,L) + FACT*WORK(L,1)
   40 CONTINUE
      RETURN
      END
      SUBROUTINE MCSXDU( N, A, B, U, M, INC, JUMP, WORK )
C
C   MULTIPLE CHEBYSHEV SPECTRAL SPACE CALCULATION OF X TIMES DERIVATIVE
C
      INTEGER  N, M, INC, JUMP
      REAL     A, B, U(JUMP,*), WORK(M,3)
      INTEGER  IK, I0, I1, K, L
      REAL     FACT, P, Q, TEMP1, TEMP2
C
      IF ( N.LT.1 )  THEN
          CALL LIBERR( 'MCSXDU', 0, 'TRUNCATION  N  MUST BE AT LEAST 1')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'MSXDU', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = 2.0*P/Q
      IK = 1 + N*INC
      DO 10 L=1,M
          WORK(L,2) = 0.0
          WORK(L,3) = N*U(IK,L)
          U(IK,L)   = WORK(L,3)
          WORK(L,1) = FACT*WORK(L,3)
   10 CONTINUE
      FACT = P/Q
      DO 30 K=N-1,1,-1
          IK = IK - INC
          DO 20 L=1,M
              TEMP1     = K*U(IK,L)
              U(IK,L)   = TEMP1 + WORK(L,1)
              TEMP2     = WORK(L,2) + 2.0*(FACT*TEMP1 + WORK(L,3))
              WORK(L,2) = WORK(L,1)
              WORK(L,1) = TEMP2
              WORK(L,3) = TEMP1
   20     CONTINUE 
   30 CONTINUE
      IK = IK - INC
      DO 40 L=1,M
   40 U(IK,L) = WORK(L,1)/2.0
      RETURN
      END
      SUBROUTINE MCSDXU( N, A, B, U, M, INC, JUMP, WORK )
C
C   MULTIPLE CHEBYSHEV SPECTRAL SPACE CALCULATION OF DERIVATIVE OF X*U
C
      INTEGER  N, M, INC, JUMP
      REAL     A, B, U(JUMP,*), WORK(M,3)
      INTEGER  IK, I0, I1, K, L
      REAL     FACT, P, Q, TEMP1, TEMP2
C
      IF ( N.LT.1 )  THEN
          CALL LIBERR( 'MCSDXU', 0, 'TRUNCATION  N  MUST BE AT LEAST 1')
          RETURN
      END IF
      P = (B + A)/2.0
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  THEN
          CALL LIBERR( 'MSDXU', 0, 'INTERVAL (A,B) HAS LENGTH ZERO' )
          RETURN
      END IF
      FACT = 2.0*P/Q
      IK = 1 + N*INC
      DO 10 L=1,M
          WORK(L,2) = 0.0
          WORK(L,3) = N*U(IK,L)
          U(IK,L)   = U(IK,L) + WORK(L,3)
          WORK(L,1) = FACT*WORK(L,3)
   10 CONTINUE
      FACT = P/Q
      DO 30 K=N-1,1,-1
          IK = IK - INC
          DO 20 L=1,M
              TEMP1     = K*U(IK,L)
              U(IK,L)   = U(IK,L) + TEMP1 + WORK(L,1)
              TEMP2     = WORK(L,2) + 2.0*(FACT*TEMP1 + WORK(L,3))
              WORK(L,2) = WORK(L,1)
              WORK(L,1) = TEMP2
              WORK(L,3) = TEMP1
   20     CONTINUE 
   30 CONTINUE
      IK = IK - INC
      DO 40 L=1,M
   40 U(IK,L) = U(IK,L) + WORK(L,1)/2.0
      RETURN
      END
      SUBROUTINE MATPRO( N, QA, QB, QC )
C
C   COMPUTES THE MATRIX PRODUCT  QA * QB = QC
C
      INTEGER  N, I, J, K
      REAL     QA(0:N,0:N), QB(0:N,0:N), QC(0:N,0:N)
C
      DO 30 K=0,N
          DO 10 I=0,N
   10     QC(I,K) = 0.0
          DO 20 J=0,N
          DO 20 I=0,N
   20     QC(I,K) = QC(I,K) + QA(I,J)*QB(J,K)
   30 CONTINUE
      RETURN
      END
      SUBROUTINE MATOP( N, U, Q, V )
C
C   COMPUTES THE MATRIX OPERATION  Q * U = V  (U  AND  V  ARE VECTORS)
C
      INTEGER  N, I, J
      REAL     U(0:N), Q(0:N,0:N), V(0:N)
C
      DO 10 I=0,N
   10 V(I) = 0.0
      DO 20 J=0,N
      DO 20 I=0,N
   20 V(I) = V(I) + Q(I,J)*U(J)
      RETURN
      END
      SUBROUTINE MMATOP( N, U, Q, M, INC, JUMP, V )
C
C   COMPUTES THE MULTIPLE MATRIX OPERATION  Q * U = V
C
      INTEGER  N, M, INC, JUMP, I, II, IK, J, L
      REAL     U(JUMP,*), Q(0:N,0:N), V(JUMP,*)
C
      II = 1
      DO 40 I=0,N
          DO 10 L=1,M
   10     V(II,L) = 0.0
          IK = 1
          DO 30 J=0,N
              DO 20 L=1,M
   20         V(II,L) = V(II,L) + Q(I,J)*U(IK,L) 
              IK = IK + INC
   30     CONTINUE 
          II = II + INC
   40 CONTINUE
      RETURN
      END
      SUBROUTINE LIBERR( RNAME, IERR, ERMESS )
C
C   PURPOSE
C
C       PRINTS ERROR MESSAGES FOR LIBRARY ROUTINES
C
C   ARGUMENTS
C
C       RNAME   ROUTINE IN WHICH THE ERROR OCCURED (CHARACTER STRING)
C
C       IERR    ERROR NUMBER (INTEGER) 
C
C       ERMESS  ERROR MESSAGE (CHARACTER STRING) 
C
C   OUTPUT
C
C       THE ERROR MESSAGE  ERMESS  IS PRINTED AND IDENTIFIED BY ROUTINE
C       NAME  RNAME  AND (IF IERR.NE.0) BY THE ERROR NUMBER  IERR.
C
      INTEGER        IERR
      CHARACTER*(*)  RNAME, ERMESS
C
C   PRINT THE ERROR MESSAGE
C
      IF ( IERR.EQ.0 )  THEN 
          PRINT 2000, RNAME, ERMESS
 2000     FORMAT('0***** ERROR IN  ',A/1X,A)
      ELSE
          PRINT 2100, RNAME, IERR, ERMESS
 2100     FORMAT('0***** ERROR IN  ',A,'  (ERROR NUMBER',I20,')'/1X,A)
      END IF
      RETURN
      END
CDIR$ NOLIST
      BLOCK DATA CSOLVE
C
C   *****  CHEBYSHEV SOLVERS FOR DIFFERENTIAL EQUATIONS  *****
C
C   LATEST REVISION         22 AUGUST 1985
C
C   CONTENTS  (SUBROUTINE NAMES LISTED BY THE EQUATION THEY SOLVE)
C
C       EQUATION 1:    U'(X) - LAMBDA*U(X) = F(X)
C
C       EQUATION 2:    U''(X) - LAMBDA*U(X) = F(X)
C
C                CHEBYSHEV-TAU SOLVERS:
C
C           CTS2    SOLVES EQUATION 2 ONCE
C
C           CTS2M   SOLVES EQUATION 2 MULTIPLE TIMES IN PARALLEL
C                   FOR DIFFERENT RIGHT-HAND SIDES (SAME LAMBDA)
C
C           MCTS2   SOLVES EQUATION 2 MULTIPLE TIMES IN PARALLEL
C                   FOR DIFFERENT LAMBDAS AND DIFFERENT RIGHT-HAND SIDES
C
C   ACCESS
C
C       THE SOURCE CODE FOR  CSOLVE  IS STORED ON  PSTORE  AND CAN BE
C       COPIED INTO A CRAY DATASET NAMES  CSFOR  BY THE STATEMENT:
C
C           PCOPY( FROM=/TB/FULTON/LIBRARY/CSOLVE.FOR TO=CSFOR )
C
C       THE OBJECT CODE FOR  CSLOVE  IS STORED ON  PSTORE  AND CAN BE
C       COPIED INTO A CRAY DATASET NAMED  CSOLVE  BY THE STATEMENT:
C
C           PCOPY( FROM=/TB/FULTON/LIBRARY/CSOLVE.LIB TO=CSOLVE )
C
C       THE COMPILED CODE FOR EACH ROUTINE CALLED BY YOUR PROGRAM WILL
C       THEN BE LOADED IF YOU SPECIFY  CSOLVE  AS A LIBRARY ON THE LDR
C       STATEMENT, E.G.,
C
C           LDR,LIB=CSOLVE.
C
C   LANGUAGE    FORTRAN 77
C
C   HISTORY     CTS2 ROUTINES WRITTEN IN JULY 1985 BY SCOTT R. FULTON
C
C
      END
      SUBROUTINE CTS2( N, A, B, IBC, ICALL, R, W, U )
C
C   PURPOSE
C
C       THIS ROUTINE SOLVES THE CHEBYSHEV-TAU APPROXIMATION TO
C
C
C             U''(X) - LAMBDA*U(X)  =  F(X)      ON    A .LT. X .LT. B
C
C       WITH DIRICHLET OR NEUMANN BOUNDARY CONDITIONS BY THE METHOD OF
C       GOTTLIEB AND ORSZAG, NUMERICAL ANALYSIS OF SPECTRAL METHODS, 
C       (1977, SECTION 10).
C
C   ARGUMENTS
C
C       DIMENSION   W(0:N,4), U(0:N)
C
C       INPUT
C
C           N       INTEGER SPECTRAL TRUNCATION (INDEX OF LAST MODE) 
C
C           A, B    REAL ENDPOINTS OF THE PROBLEM DOMAIN
C
C           IBC     INTEGER SPECIFYING THE BOUNDARY CONDITIONS:
C                     .EQ.0  DIRICHLET CONDITIONS (U(A), U(B) SPECIFIED)
C                     .NE.0  NEUMANN CONDITIONS (U'(A), U'(B) SPECIFIED)
C
C           ICALL   INTEGER SPECIFYING INITIALIZATION, SOLUTION OR BOTH:
C                     .LE.0  INITIALIZE ONLY (COMPUTE  W)
C                     .EQ.1  INITIALIZE AND SOLVE FOR  U
C                     .GE.2  SOLVE FOR  U  USING  W  COMPUTED PREVIOUSLY
C
C           R       REAL VALUE OF  LAMBDA  IN THE EQUATION TO BE SOLVED
C
C           W       REAL ARRAY OF SIZE AT LEAST 4*(N+1), USED TO STORE
C                   COEFFICIENTS COMPUTED IN THE INITIALIZATION PHASE.
C                   IF  R=0.0,  ONLY THE FIRST  N+1  LOCATIONS ARE USED.
C                   NOTE:  FOR  ICALL.GE.2,  W  MUST BE UNCHANGED FROM
C                   A PREVIOUS CALL WITH THE SAME  N, A, B,  AND  R. 
C
C           U       REAL VECTOR OF LENGTH  N+1  CONTAINING THE DATA: 
C                   FOR  K = 0, ..., N-2,  U(K)  IS THE  KTH  SPECTRAL
C                   COEFFICIENT OF THE RIGHT-HAND SIDE FUNCTION  F,
C                   WHILE  U(N-1)  AND  U(N)  CONTAIN THE DESIRED VALUES
C                   OF  U  (IF  IBC.EQ.0)  OR  U'  (IF  IBC.NE.0)  AT
C                   THE BOUNDARIES  X=A  AND  X=B,  RESPECTIVELY.
C
C       OUTPUT
C
C           U       CONTAINS THE SPECTRAL COEFFICIENTS OF THE SOLUTION U
C
C   SOLVABILITY CONDITION
C
C       WHEN  LAMBDA = 0  WITH NEUMANN BOUNDARY CONDITIONS, THE PROBLEM
C       HAS A SOLUTION (UNIQUE UP TO AN ADDITIVE CONSTANT) ONLY IF
C
C            U'(B) - U'(A) - INTEGRAL (X=A TO X=B) OF F(X) 
C
C       VANISHES.  IN THIS CASE,  CTS2  RETURNS THE NUMERICAL VALUE OF
C       THE ABOVE QUANTITY IN PLACE OF THE ZEROTH SPECTRAL COEFFICIENT,
C       WHICH IS ARBITRARY ANYWAY.  IT IS LEFT TO THE USER TO CHECK THIS
C       VALUE TO SEE WHETHER IT IS SUITABLY CLOSE TO ZERO.  IF IT IS NOT
C       THEN THE EQUATION IS SATISFIED BUT NOT THE BOUNDARY CONDITIONS.
C
C   ERROR CONDITIONS
C
C       (1) IF  N.LT.2  THEN NO ACTION IS TAKEN. 
C       (2) IN ORDER TO GUARANTEE A SOLUTION, ONE OF THE FOLLOWING TWO
C           CONDITIONS MUST HOLD:
C
C               (A) LAMBDA = 0, OR
C               (B) 0 .LT. LAMBDA*(B - A)**2 .LT. 16*(N-1)*(N-2).
C
C           IF NEITHER (A) NOR (B) HOLDS, THIS ROUTINE MAY PRODUCE
C           ERRONEOUS RESULTS (DUE TO ROUNDOFF ERROR), OR POSSIBLY
C           CRASH TRYING TO DIVIDE BY ZERO.
C
C
      INTEGER  N, IBC, ICALL 
      REAL     A, B, R, W(0:N,4), U(0:N)
      INTEGER  I0, K
      REAL     BVSUM, BVDIF, Q, T0, T1, T2
C
C ***** INITIALIZATION ***** 
C
      IF ( N.LT.2 )    RETURN
      IF ( ICALL.GT.1 )  GO TO 100
C
C   GENERATE THE TRIDIAGONAL MATRIX ELEMENTS IN  W(.,1), W(.,2), W(.,3)
C
      I0 = 1
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      T0 = Q*Q/8.0 
      DO 10 K=2,N
          W(K,1) = T0/REAL( I0 )
          I0 = I0 + K
   10 CONTINUE
      IF ( R.EQ.0.0 )  GO TO 60
      DO 20 K=2,N-2
          W(K,2) = 1.0 + R*(W(K,1) + W(K+1,1))
          W(K,3) = -R*W(K+1,1)
   20 CONTINUE
      W(N-1,2) = 1.0
      W(N  ,2) = 1.0
C
C   COMPUTE THE LU DECOMPOSITION (PRESERVING THE LOWER DIAGONAL)
C
      DO 30 K=4,N-2
          W(K-2,3) = W(K-2,3)/W(K-2,2) 
          W(K  ,2) = W(K,2) + R*W(K,1)*W(K-2,3)
   30 CONTINUE
C
C   SOLVE FOR  W  IN  W(.,4) 
C
      W(0,4) = 1.0 
      W(1,4) = 1.0 
      DO 40 K=2,N
   40 W(K,4) = R*W(K,1)*W(K-2,4)/W(K,2)
      DO 50 K=N-4,2,-1
   50 W(K,4) = W(K,4) - W(K,3)*W(K+2,4)
C
C   STORE SUMS FOR APPLYING BOUNDARY CONDITIONS IN  W(0,1)  AND  W(1,1)
C
   60 IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  W(N)/C(N)
C
          IF ( R.EQ.0.0 )  THEN
              W(1,1) = 1.0
              W(0,1) = 0.5
          ELSE
              T1 = 0.0
              T0 = W(N,4)
              I0 = N-1
              IF ( MOD( N, 2 ).NE.0 )  THEN
                  T0 = 0.0
                  I0 = N
              END IF
              DO 70 K=I0,3,-2
                  T1 = T1 + W(K  ,4)
                  T0 = T0 + W(K-1,4)
   70         CONTINUE
              W(1,1) = 1.0 + T1
              W(0,1) = 0.5 + T0
          END IF
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*W(N)
C
          IF ( R.EQ.0.0 )  THEN
              W(1,1) = 1.0
              W(0,1) = Q/4.0 
          ELSE
              T1 = 0.0
              T0 = (N*N)*W(N,4)
              I0 = N-1
              IF ( MOD( N, 2 ).NE.0 )  THEN
                  T0 = 0.0
                  I0 = N
              END IF
              DO 80 K=I0,3,-2
                  T1 = T1 + ( K   * K   )*W(K  ,4)
                  T0 = T0 + ((K-1)*(K-1))*W(K-1,4)
   80         CONTINUE
              W(1,1) = 1.0 + T1
              W(0,1) =       T0
          END IF
C
      END IF
      IF ( ICALL.LE.0 )  RETURN
C
C ***** SOLUTION *****
C
C   GENERATE THE RIGHT-HAND SIDE IN  U  (STORING THE BOUNDARY VALUES)
C
  100 BVSUM = (U(N) + U(N-1))/2.0
      BVDIF = (U(N) - U(N-1))/2.0
      U(0) = 2.0*U(0)
      U(N) = W(N,1)*U(N-2)
      IF ( N.EQ.2 )  GO TO 120
      U(N-1) = W(N-1,1)*U(N-3)
      T1 = 0.0
      T0 = 0.0
      DO 110 K=N-2,2,-1
          T2 = T1
          T1 = T0
          T0 = U(K)
          U(K) = W(K,1)*(U(K-2) - T0) + W(K+1,1)*(T2 - T0) 
  110 CONTINUE
  120 U(1) = 0.0
      U(0) = 0.0
      IF ( R.EQ.0.0 )  GO TO 150
C
C    SOLVE FOR  V  IN  U
C
      DO 130 K=2,N 
  130 U(K) = (U(K) + R*W(K,1)*U(K-2))/W(K,2)
      DO 140 K=N-4,2,-1
  140 U(K) = U(K) - W(K,3)*U(K+2)
C
C   COMPUTE  ALPHA,  BETA  IN  U(0),  U(1)  FROM BOUNDARY CONDITIONS 
C
  150 IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  V(N)
C
          T1 = 0.0 
          T0 = U(N)
          I0 = N-1 
          IF ( MOD( N, 2 ).NE.0 )  THEN
              T0 = 0.0
              I0 = N
          END IF
          DO 160 K=I0,3,-2
              T1 = T1 + U(K) 
              T0 = T0 + U(K-1)
  160     CONTINUE 
          U(0) = (BVSUM - T0)/W(0,1)
          U(1) = (BVDIF - T1)/W(1,1)
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*V(N)
C
          T1 = 0.0 
          T0 = (N*N)*U(N)
          I0 = N-1 
          IF ( MOD( N, 2 ).NE.0 )  THEN
              T0 = 0.0
              I0 = N
          END IF
          DO 170 K=I0,3,-2
              T1 = T1 + ( K   * K   )*U(K)
              T0 = T0 + ((K-1)*(K-1))*U(K-1)
  170     CONTINUE 
          Q = (B - A)/2.0
          IF ( Q.EQ.0.0 )  Q = 1.0
          U(0) = (Q*BVDIF - T0)/W(0,1) 
          U(1) = (Q*BVSUM - T1)/W(1,1) 
C
      END IF
C
C   ADD  W  TO  V  TO SATISFY THE BOUNDARY CONDITIONS
C
      IF ( R.EQ.0.0 )  GO TO 200
CDIR$ IVDEP
      DO 180 K=2,N,2
  180 U(K) = U(K) + U(0)*W(K,4)
CDIR$ IVDEP
      DO 190 K=3,N,2
  190 U(K) = U(K) + U(1)*W(K,4)
  200 U(0) = U(0)/2.0
      RETURN
      END
      SUBROUTINE CTS2M( N, A, B, IBC, ICALL, R, W, M, INC, JUMP, U, V )
C
C   PURPOSE
C
C       THIS ROUTINE SOLVES THE CHEBYSHEV-TAU APPROXIMATION TO
C
C
C             U''(X) - LAMBDA*U(X)  =  F(X)      ON    A .LT. X .LT. B
C
C       WITH DIRICHLET OR NEUMANN BOUNDARY CONDITIONS BY THE METHOD OF
C       GOTTLIEB AND ORSZAG, NUMERICAL ANALYSIS OF SPECTRAL METHODS, 
C       (1977, SECTION 10).  THE PROBLEM IS SOLVED  M  TIMES IN PARALLEL
C       FOR  M  DIFFERENT SETS OF DATA (F AND BOUNDARY VALUES).
C
C   ARGUMENTS
C
C       DIMENSION   W(0:N,4), U(?), V(M,4)
C
C       INPUT
C
C           N       INTEGER SPECTRAL TRUNCATION (INDEX OF LAST MODE) 
C
C           A, B    REAL ENDPOINTS OF THE PROBLEM DOMAIN
C
C           IBC     INTEGER SPECIFYING THE BOUNDARY CONDITIONS:
C                     .EQ.0  DIRICHLET CONDITIONS (U(A), U(B) SPECIFIED)
C                     .NE.0  NEUMANN CONDITIONS (U'(A), U'(B) SPECIFIED)
C
C           ICALL   INTEGER SPECIFYING INITIALIZATION, SOLUTION OR BOTH:
C                     .LE.0  INITIALIZE ONLY (COMPUTE  W)
C                     .EQ.1  INITIALIZE AND SOLVE FOR  U
C                     .GE.2  SOLVE FOR  U  USING  W  COMPUTED PREVIOUSLY
C
C           R       REAL VALUE OF  LAMBDA  IN THE EQUATION TO BE SOLVED
C
C           W       REAL ARRAY OF SIZE AT LEAST 4*(N+1), USED TO STORE
C                   COEFFICIENTS COMPUTED IN THE INITIALIZATION PHASE.
C                   IF  R=0.0,  ONLY THE FIRST  N+1  LOCATIONS ARE USED.
C                   NOTE:  FOR  ICALL.GE.2,  W  MUST BE UNCHANGED FROM
C                   A PREVIOUS CALL WITH THE SAME  N, A, B,  AND  R. 
C
C           M       INTEGER NUMBER OF TIMES TO SOLVE THE EQUATION
C
C           INC     INTEGER STORAGE INCREMENT FOR  U  (SEE  U  BELOW)
C
C           JUMP    INTEGER STORAGE INCREMENT FOR  U  (SEE  U  BELOW)
C
C           U       REAL VECTOR OR ARRAY CONTAINING THE DATA, I.E.,
C                   THE SPECTRAL COEFFICIENTS  F(0), F(1), ..., F(N-2)
C                   OF THE RIGHT-HAND SIDE FUNCTION  F,  FOLLOWED BY 
C                   THE DESIRED VALUES OF  U  (IF  IBC.EQ.0)  OR  U' 
C                   (IF  IBC.NE.0)  AT  X=A  AND  X=B,  RESPECTIVELY.
C                   THERE MUST BE  M  SUCH SETS OF  N+1  DATA VALUES 
C                   STORED IN  U,  STARTING WITH THE FIRST LOCATION, 
C                   WITH STORAGE INCREMENT  INC  BETWEEN SUCCESSIVE
C                   DATA ELEMENTS IN EACH DATA SET AND INCREMENT  JUMP
C                   BETWEEN CORRESPONDING ELEMENTS IN SUCCESSIVE SETS.
C                   NOTE:  STORAGE IS COMPATIBLE WITH THAT OF  MCTRAN.
C
C       WORK SPACE 
C
C           V       REAL ARRAY OF LENGTH AT LEAST  4*M
C
C       OUTPUT
C
C           U       CONTAINS THE SOLUTION, I.E., THE CHEBYSHEV SPECTRAL
C                   COEFFICIENTS  U(0), U(1), ..., U(N)  OF THE SOLUTION
C                   FUNCTION  U.  THERE ARE  M  SUCH SETS OF  N+1
C                   COEFFICIENTS, ONE FOR EACH DATA SET INPUT, STORED
C                   IN THE SAME LOCATIONS USED FOR THE INPUT DATA SETS.
C
C   SOLVABILITY CONDITION
C
C       WHEN  LAMBDA = 0  WITH NEUMANN BOUNDARY CONDITIONS, THE PROBLEM
C       HAS A SOLUTION (UNIQUE UP TO AN ADDITIVE CONSTANT) ONLY IF
C
C            U'(B) - U'(A) - INTEGRAL (X=A TO X=B) OF F(X) 
C
C       VANISHES.  IN THIS CASE,  CTS2M  RETURNS THE NUMERICAL VALUE OF
C       THE ABOVE QUANTITY IN PLACE OF THE ZEROTH SPECTRAL COEFFICIENT,
C       WHICH IS ARBITRARY ANYWAY.  IT IS LEFT TO THE USER TO CHECK THIS
C       VALUE TO SEE WHETHER IT IS SUITABLY CLOSE TO ZERO.  IF IT IS NOT
C       THEN THE EQUATION IS SATISFIED BUT NOT THE BOUNDARY CONDITIONS.
C
C   ERROR CONDITIONS
C
C       (1) IF  N.LT.2  THEN NO ACTION IS TAKEN. 
C       (2) IN ORDER TO GUARANTEE A SOLUTION, ONE OF THE FOLLOWING TWO
C           CONDITIONS MUST HOLD:
C
C               (A) LAMBDA = 0, OR
C               (B) 0 .LT. LAMBDA*(B - A)**2 .LT. 16*(N-1)*(N-2).
C
C           IF NEITHER (A) NOR (B) HOLDS, THIS ROUTINE MAY PRODUCE
C           ERRONEOUS RESULTS (DUE TO ROUNDOFF ERROR), OR POSSIBLY
C           CRASH TRYING TO DIVIDE BY ZERO.
C
C
      INTEGER  N, IBC, ICALL, M, INC, JUMP
      REAL     A, B, R, W(0:N,4), U(JUMP,*), V(M,0:3)
      INTEGER  I0, I1, I2, IK, IN, K, K1, KK, KS, L
      REAL     Q, T0, T1, T2 
C
C ***** INITIALIZATION ***** 
C
      IF ( N.LT.2 )    RETURN
      IF ( ICALL.GT.1 )  GO TO 100
C
C   GENERATE THE TRIDIAGONAL MATRIX ELEMENTS IN  W(.,1), W(.,2), W(.,3)
C
      I0 = 1
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      T0 = Q*Q/8.0 
      DO 10 K=2,N
          W(K,1) = T0/REAL( I0 )
          I0 = I0 + K
   10 CONTINUE
      IF ( R.EQ.0.0 )  GO TO 60
      DO 20 K=2,N-2
          W(K,2) = 1.0 + R*(W(K,1) + W(K+1,1))
          W(K,3) = -R*W(K+1,1)
   20 CONTINUE
      W(N-1,2) = 1.0
      W(N  ,2) = 1.0
C
C   COMPUTE THE LU DECOMPOSITION (PRESERVING THE LOWER DIAGONAL)
C
      DO 30 K=4,N-2
          W(K-2,3) = W(K-2,3)/W(K-2,2) 
          W(K  ,2) = W(K,2) + R*W(K,1)*W(K-2,3)
   30 CONTINUE
C
C   SOLVE FOR  W  IN  W(.,4) 
C
      W(0,4) = 1.0 
      W(1,4) = 1.0 
      DO 40 K=2,N
   40 W(K,4) = R*W(K,1)*W(K-2,4)/W(K,2)
      DO 50 K=N-4,2,-1
   50 W(K,4) = W(K,4) - W(K,3)*W(K+2,4)
C
C   STORE SUMS FOR APPLYING BOUNDARY CONDITIONS IN  W(0,1)  AND  W(1,1)
C
   60 IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  W(N)/C(N)
C
          IF ( R.EQ.0.0 )  THEN
              W(1,1) = 1.0
              W(0,1) = 0.5
          ELSE
              T1 = 0.0
              T0 = W(N,4)
              I0 = N-1
              IF ( MOD( N, 2 ).NE.0 )  THEN
                  T0 = 0.0
                  I0 = N
              END IF
              DO 70 K=I0,3,-2
                  T1 = T1 + W(K  ,4)
                  T0 = T0 + W(K-1,4)
   70         CONTINUE
              W(1,1) = 1.0 + T1
              W(0,1) = 0.5 + T0
          END IF
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*W(N)
C
          IF ( R.EQ.0.0 )  THEN
              W(1,1) = 1.0
              W(0,1) = Q/4.0 
          ELSE
              T1 = 0.0
              T0 = (N*N)*W(N,4)
              I0 = N-1
              IF ( MOD( N, 2 ).NE.0 )  THEN
                  T0 = 0.0
                  I0 = N
              END IF
              DO 80 K=I0,3,-2
                  T1 = T1 + ( K   * K   )*W(K  ,4)
                  T0 = T0 + ((K-1)*(K-1))*W(K-1,4)
   80         CONTINUE
              W(1,1) = 1.0 + T1
              W(0,1) =       T0
          END IF
C
      END IF
      IF ( ICALL.LE.0 )  RETURN
C
C ***** SOLUTION *****
C
C   SET POINTERS TO THE LOCATIONS OF THE  K=0  AND  K=N  MODES IN  U 
C
  100 I0 = 1
      IN = I0 + N*INC
C
C   GENERATE THE RIGHT-HAND SIDE IN  U  (STORING THE BOUNDARY VALUES)
C
      I1 = IN - INC
      I2 = I1 - INC
      DO 110 L=1,M 
          V(L,2) = (U(IN,L) + U(I1,L))/2.0
          V(L,3) = (U(IN,L) - U(I1,L))/2.0
          U(I0,L) = 2.0*U(I0,L)
          U(IN,L) = W(N,1)*U(I2,L)
  110 CONTINUE
      IF ( N.EQ.2 )  GO TO 150
      IK = I1
      I1 = I2
      I2 = I2 - INC
      DO 120 L=1,M 
          U(IK,L) = W(N-1,1)*U(I2,L)
          V(L,1) = 0.0
          V(L,0) = 0.0
  120 CONTINUE
      DO 140 K=N-2,2,-1
          IK = I1
          I1 = I2
          I2 = I2 - INC
          DO 130 L=1,M
              T2 = V(L,1)
              V(L,1) = V(L,0)
              V(L,0) = U(IK,L)
              U(IK,L) = W(K  ,1)*(U(I2,L) - V(L,0))
     2                + W(K+1,1)*(T2      - V(L,0))
  130     CONTINUE 
  140 CONTINUE
  150 I1 = I0 + INC
      DO 160 L=1,M 
          U(I1,L) = 0.0
          U(I0,L) = 0.0
  160 CONTINUE
      IF ( R.EQ.0.0 )  GO TO 210
C
C    SOLVE FOR  V  IN  U
C
      I2 = I0
      I1 = I2 + INC
      IK = I1 + INC
      DO 180 K=2,N 
          DO 170 L=1,M
  170     U(IK,L) = (U(IK,L) + R*W(K,1)*U(I2,L))/W(K,2)
          I2 = I1
          I1 = IK
          IK = IK + INC
  180 CONTINUE
      I2 = IN - 2*INC
      I1 = I2 - INC
      IK = I1 - INC
      DO 200 K=N-4,2,-1
          DO 190 L=1,M
  190     U(IK,L) = U(IK,L) - W(K,3)*U(I2,L)
          I2 = I1
          I1 = IK
          IK = IK - INC
  200 CONTINUE
C
C   COMPUTE  ALPHA,  BETA  IN  U(I0),  U(I1)  FROM BOUNDARY CONDITIONS
C
  210 IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  V(N)
C
          DO 220 L=1,M
              V(L,1) = 0.0
              V(L,0) = U(IN,L)
  220     CONTINUE 
          KS = N-1 
          IK = IN - INC
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 230 L=1,M
  230         V(L,0) = 0.0
              KS = N
              IK = IN
          END IF
          I1 = IK - INC
          DO 250 K=KS,3,-2
              DO 240 L=1,M
                  V(L,1) = V(L,1) + U(IK,L)
                  V(L,0) = V(L,0) + U(I1,L)
  240         CONTINUE
              IK = I1 - INC
              I1 = IK - INC
  250     CONTINUE 
          I1 = I0 + INC
          DO 260 L=1,M
              U(I0,L) = (V(L,2) - V(L,0))/W(0,1) 
              U(I1,L) = (V(L,3) - V(L,1))/W(1,1) 
  260     CONTINUE 
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*V(N)
C
          KK = N*N 
          DO 270 L=1,M
              V(L,1) = 0.0
              V(L,0) = KK*U(IN,L)
  270     CONTINUE 
          KS = N-1 
          IK = IN - INC
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 280 L=1,M
  280         V(L,0) = 0.0
              KS = N
              IK = IN
          END IF
          I1 = IK - INC
          DO 300 K=KS,3,-2
              KK = K*K
              K1 = (K-1)*(K-1)
              DO 290 L=1,M
                  V(L,1) = V(L,1) + KK*U(IK,L)
                  V(L,0) = V(L,0) + K1*U(I1,L)
  290         CONTINUE
              IK = I1 - INC
              I1 = IK - INC
  300     CONTINUE 
          Q = (B - A)/2.0
          IF ( Q.EQ.0.0 )  Q = 1.0
          I1 = I0 + INC
          DO 310 L=1,M
              U(I0,L) = (Q*V(L,3) - V(L,0))/W(0,1)
              U(I1,L) = (Q*V(L,2) - V(L,1))/W(1,1)
  310     CONTINUE 
C
      END IF
C
C   ADD  W  TO  V  TO SATISFY THE BOUNDARY CONDITIONS
C
      IF ( R.EQ.0.0 )  GO TO 350
      IK = I1 + INC
      DO 340 K=2,N 
          IF ( MOD( K, 2 ).EQ.0 )  THEN
              DO 320 L=1,M
  320         U(IK,L) = U(IK,L) + U(I0,L)*W(K,4) 
          ELSE
              DO 330 L=1,M
  330         U(IK,L) = U(IK,L) + U(I1,L)*W(K,4) 
          END IF
          IK = IK + INC
  340 CONTINUE
  350 DO 360 L=1,M 
  360 U(I0,L) = U(I0,L)/2.0
      RETURN
      END
      SUBROUTINE MCTS2( N, A, B, IBC, ICALL, M, R, W, INC, JUMP, U ) 
C
C   PURPOSE
C
C       THIS ROUTINE SOLVES THE CHEBYSHEV-TAU APPROXIMATION TO
C
C
C             U''(X) - LAMBDA*U(X)  =  F(X)      ON    A .LT. X .LT. B
C
C       WITH DIRICHLET OR NEUMANN BOUNDARY CONDITIONS BY THE METHOD OF
C       GOTTLIEB AND ORSZAG, NUMERICAL ANALYSIS OF SPECTRAL METHODS, 
C       (1977, SECTION 10).  M  SUCH PROBLEMS ARE SOLVED IN PARALLEL,
C       EACH WITH ITS OWN  LAMBDA  AND DATA (F AND BOUNDARY VALUES). 
C
C   ARGUMENTS
C
C       DIMENSION   W(0:N,3*M+1), U(?) 
C
C       INPUT
C
C           N       INTEGER SPECTRAL TRUNCATION (INDEX OF LAST MODE) 
C
C           A, B    REAL ENDPOINTS OF THE PROBLEM DOMAIN
C
C           IBC     INTEGER SPECIFYING THE BOUNDARY CONDITIONS:
C                     .EQ.0  DIRICHLET CONDITIONS (U(A), U(B) SPECIFIED)
C                     .NE.0  NEUMANN CONDITIONS (U'(A), U'(B) SPECIFIED)
C
C           ICALL   INTEGER SPECIFYING INITIALIZATION, SOLUTION OR BOTH:
C                     .LE.0  INITIALIZE ONLY (COMPUTE  W)
C                     .EQ.1  INITIALIZE AND SOLVE FOR  U
C                     .GE.2  SOLVE FOR  U  USING  W  COMPUTED PREVIOUSLY
C
C           M       INTEGER NUMBER OF PROBLEMS TO BE SOLVED IN PARALLEL
C
C           R       REAL VECTOR OF LENGTH  M:  R(J)  IS THE VALUE OF 
C                   THE CONSTANT  LAMBDA  FOR PROBLEM  J = 1, ..., M.
C
C           W       REAL ARRAY OF SIZE AT LEAST (3*M+1)*(N+1) (USED TO
C                   STORE COEFFICIENTS COMPUTED IN INITIALIZATION PHASE)
C
C           INC     INTEGER STORAGE INCREMENT FOR  U  (SEE  U  BELOW)
C
C           JUMP    INTEGER STORAGE INCREMENT FOR  U  (SEE  U  BELOW)
C
C           U       REAL VECTOR OR ARRAY CONTAINING THE DATA, I.E.,
C                   THE SPECTRAL COEFFICIENTS  F(0), F(1), ..., F(N-2)
C                   OF THE RIGHT-HAND SIDE FUNCTION  F,  FOLLOWED BY 
C                   THE DESIRED VALUES OF  U  (IF  IBC.EQ.0)  OR  U' 
C                   (IF  IBC.NE.0)  AT  X=A  AND  X=B,  RESPECTIVELY.
C                   THERE MUST BE  M  SUCH SETS OF  N+1  DATA VALUES 
C                   STORED IN  U  (ONE FOR EACH OF THE  M  PROBLEMS
C                   TO BE SOLVED), STARTING WITH THE FIRST LOCATION, 
C                   WITH STORAGE INCREMENT  INC  BETWEEN SUCCESSIVE DATA
C                   DATA ELEMENTS FOR EACH PROBLEM AND  JUMP  BETWEEN
C                   CORRESPONDING ELEMENTS FOR SUCCESSIVE PROBLEMS.
C                   NOTE:  STORAGE IS COMPATIBLE WITH THAT OF  MCTRAN.
C
C       OUTPUT
C
C           U       CONTAINS THE SOLUTION, I.E., THE CHEBYSHEV SPECTRAL
C                   COEFFICIENTS  U(0), U(1), ..., U(N)  OF THE SOLUTION
C                   FUNCTION  U.  THERE ARE  M  SUCH SETS OF  N+1
C                   COEFFICIENTS, ONE FOR EACH PROBLEM SOLVED, STORED
C                   IN THE SAME LOCATIONS USED FOR THE INPUT DATA SETS.
C
C   SOLVABILITY CONDITION
C
C       WHEN  LAMBDA = 0  WITH NEUMANN BOUNDARY CONDITIONS, THE PROBLEM
C       HAS A SOLUTION (UNIQUE UP TO AN ADDITIVE CONSTANT) ONLY IF
C
C            U'(B) - U'(A) - INTEGRAL (X=A TO X=B) OF F(X) 
C
C       VANISHES.  IN THIS CASE,  MCTS2  RETURNS THE NUMERICAL VALUE OF
C       THE ABOVE QUANTITY IN PLACE OF THE ZEROTH SPECTRAL COEFFICIENT,
C       WHICH IS ARBITRARY ANYWAY.  IT IS LEFT TO THE USER TO CHECK THIS
C       VALUE TO SEE WHETHER IT IS SUITABLY CLOSE TO ZERO.  IF IT IS NOT
C       THEN THE EQUATION IS SATISFIED BUT NOT THE BOUNDARY CONDITIONS.
C
C   ERROR CONDITIONS
C
C       (1) IF  N.LT.2  THEN NO ACTION IS TAKEN. 
C       (2) IN ORDER TO GUARANTEE A SOLUTION, ONE OF THE FOLLOWING TWO
C           CONDITIONS MUST HOLD:
C
C               (A) LAMBDA = 0, OR
C               (B) 0 .LT. LAMBDA*(B - A)**2 .LT. 16*(N-1)*(N-2).
C
C           IF NEITHER (A) NOR (B) HOLDS, THIS ROUTINE MAY PRODUCE
C           ERRONEOUS RESULTS (DUE TO ROUNDOFF ERROR), OR POSSIBLY
C           CRASH TRYING TO DIVIDE BY ZERO.
C
C
      INTEGER  N, IBC, ICALL, M, INC, JUMP
      REAL     A, B, R(M), W(M,0:N,4), U(JUMP,*) 
      INTEGER  I0, I1, I2, IK, IN, K, K1, KK, KS, L
      REAL     Q, T0, T2
C
C ***** INITIALIZATION ***** 
C
      IF ( N.LT.2 )    RETURN
      IF ( ICALL.GT.1 )  GO TO 200
C
C   GENERATE THE NUMBERS  A(K)  IN  W(K,0,4)  (SAME FOR EACH EQUATION)
C
      I0 = 1
      Q = (B - A)/2.0
      IF ( Q.EQ.0.0 )  Q = 1.0
      T0 = Q*Q/8.0 
      DO 10 K=2,N
          W(K,0,4) = T0/REAL( I0 )
          I0 = I0 + K
   10 CONTINUE
C
C   GENERATE THE REMAINING MATRIX ELEMENTS IN  W(L,.,2)  AND  W(L,.,3)
C
      DO 20 K=2,N-2
      DO 20 L=1,M
          W(L,K,2) = 1.0 + R(L)*(W(K,0,4) + W(K+1,0,4))
          W(L,K,3) = -R(L)*W(K+1,0,4)
   20 CONTINUE
      DO 30 L=1,M
          W(L,N-1,2) = 1.0
          W(L,N  ,2) = 1.0
   30 CONTINUE
C
C   COMPUTE THE LU DECOMPOSITIONS (PRESERVING THE LOWER DIAGONAL)
C
      DO 40 K=4,N-2
      DO 40 L=1,M
          W(L,K-2,3) = W(L,K-2,3)/W(L,K-2,2)
          W(L,K  ,2) = W(L,K,2) + R(L)*W(K,0,4)*W(L,K-2,3) 
   40 CONTINUE
C
C   SOLVE FOR  W  IN  W(L,.,1)
C
      DO 50 L=1,M
          W(L,0,1) = 1.0
          W(L,1,1) = 1.0
   50 CONTINUE
      DO 60 K=2,N
      DO 60 L=1,M
   60 W(L,K,1) = R(L)*W(K,0,4)*W(L,K-2,1)/W(L,K,2)
      DO 70 K=N-4,2,-1
      DO 70 L=1,M
   70 W(L,K,1) = W(L,K,1) - W(L,K,3)*W(L,K+2,1)
C
C   STORE SUM OF  W(N)/C(N)  FOR EVEN AND ODD N IN W(L,0,1) AND W(L,1,1)
C
      IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  W(N)/C(N)
C
          DO 80 L=1,M
              W(L,1,1) = 0.0 
              W(L,0,1) = W(L,N,1)
   80     CONTINUE 
          KS = N-1 
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 90 L=1,M
   90         W(L,0,1) = 0.0 
              KS = N
          END IF
          DO 100 K=KS,3,-2
          DO 100 L=1,M
              W(L,1,1) = W(L,1,1) + W(L,K  ,1)
              W(L,0,1) = W(L,0,1) + W(L,K-1,1)
  100     CONTINUE 
          DO 110 L=1,M
              W(L,1,1) = 1.0 + W(L,1,1)
              W(L,0,1) = 0.5 + W(L,0,1)
  110     CONTINUE 
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*W(N)
C
          KK = N*N 
          DO 120 L=1,M
              W(L,1,1) = 0.0 
              W(L,0,1) = KK*W(L,N,1)
  120     CONTINUE 
          KS = N-1 
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 130 L=1,M
  130         W(L,0,1) = 0.0 
              KS = N
          END IF
          DO 150 K=KS,3,-2
              KK = K*K
              K1 = (K-1)*(K-1)
              DO 140 L=1,M
                  W(L,1,1) = W(L,1,1) + KK*W(L,K  ,1)
                  W(L,0,1) = W(L,0,1) + K1*W(L,K-1,1)
  140         CONTINUE
  150     CONTINUE 
          DO 160 L=1,M
  160     W(L,1,1) = 1.0 + W(L,1,1)
          T0 = Q/4.0
          DO 170 L=1,M
              IF ( R(L).EQ.0.0 )  W(L,0,1) = T0
  170     CONTINUE 
C
      END IF
      IF ( ICALL.LE.0 )  RETURN
C
C ***** SOLUTION *****
C
C   SET INDEX POINTERS TO THE LOCATIONS OF THE  K=0  AND  K=N  MODES 
C
  200 I0 = 1
      IN = I0 + N*INC
C
C   GENERATE THE RIGHT-HAND SIDE IN  U  (STORING THE BOUNDARY VALUES)
C
      I1 = IN - INC
      I2 = I1 - INC
      DO 210 L=1,M 
          W(L,0,3) = (U(IN,L) + U(I1,L))/2.0
          W(L,1,3) = (U(IN,L) - U(I1,L))/2.0
          U(I0,L) = 2.0*U(I0,L)
          U(IN,L) = W(N,0,4)*U(I2,L)
  210 CONTINUE
      IF ( N.EQ.2 )  GO TO 250
      IK = I1
      I1 = I2
      I2 = I2 - INC
      DO 220 L=1,M 
          U(IK,L) = W(N-1,0,4)*U(I2,L) 
          W(L,N-1,3) = 0.0
          W(L,N  ,3) = 0.0
  220 CONTINUE
      DO 240 K=N-2,2,-1
          IK = I1
          I1 = I2
          I2 = I2 - INC
          DO 230 L=1,M
              T2         = W(L,N-1,3)
              W(L,N-1,3) = W(L,N  ,3)
              W(L,N  ,3) = U(IK,L)
              U(IK,L) = W(K,  0,4)*(U(I2,L) - W(L,N,3))
     2                + W(K+1,0,4)*(T2      - W(L,N,3))
  230     CONTINUE 
  240 CONTINUE
  250 I1 = I0 + INC
      DO 260 L=1,M 
          U(I1,L) = 0.0
          U(I0,L) = 0.0
  260 CONTINUE
C
C    SOLVE FOR  V  IN  U
C
      I2 = I0
      I1 = I2 + INC
      IK = I1 + INC
      DO 280 K=2,N 
          DO 270 L=1,M
  270     U(IK,L) = (U(IK,L) +
     2                    R(L)*W(K,0,4)*U(I2,L))/W(L,K,2)
          I2 = I1
          I1 = IK
          IK = IK + INC
  280 CONTINUE
      I2 = IN - 2*INC
      I1 = I2 - INC
      IK = I1 - INC
      DO 300 K=N-4,2,-1
          DO 290 L=1,M
  290     U(IK,L) = U(IK,L) - W(L,K,3)*U(I2,L)
          I2 = I1
          I1 = IK
          IK = IK - INC
  300 CONTINUE
C
C   COMPUTE  ALPHA,  BETA  IN  U(I0),  U(I1)  FROM BOUNDARY CONDITIONS
C
      IF ( IBC.EQ.0 )  THEN
C
C       DIRICHLET BOUNDARY CONDITIONS:  SUM  V(N)
C
          DO 310 L=1,M
              W(L,1,2) = 0.0 
              W(L,0,2) = U(IN,L)
  310     CONTINUE 
          KS = N-1 
          IK = IN - INC
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 320 L=1,M
  320         W(L,0,2) = 0.0 
              KS = N
              IK = IN
          END IF
          I1 = IK - INC
          DO 340 K=KS,3,-2
              DO 330 L=1,M
                  W(L,1,2) = W(L,1,2) + U(IK,L)
                  W(L,0,2) = W(L,0,2) + U(I1,L)
  330         CONTINUE
              IK = I1 - INC
              I1 = IK - INC
  340     CONTINUE 
          I1 = I0 + INC
          DO 350 L=1,M
              U(I0,L) = (W(L,0,3) - W(L,0,2))/W(L,0,1)
              U(I1,L) = (W(L,1,3) - W(L,1,2))/W(L,1,1)
  350     CONTINUE 
C
      ELSE
C
C       NEUMANN BOUNDARY CONDITIONS:  SUM  N*N*V(N)
C
          KK = N*N 
          DO 360 L=1,M
              W(L,1,2) = 0.0 
              W(L,0,2) = KK*U(IN,L)
  360     CONTINUE 
          KS = N-1 
          IK = IN - INC
          IF ( MOD( N, 2 ).NE.0 )  THEN
              DO 370 L=1,M
  370         W(L,0,2) = 0.0 
              KS = N
              IK = IN
          END IF
          I1 = IK - INC
          DO 390 K=KS,3,-2
              KK = K*K
              K1 = (K-1)*(K-1)
              DO 380 L=1,M
                  W(L,1,2) = W(L,1,2) + KK*U(IK,L)
                  W(L,0,2) = W(L,0,2) + K1*U(I1,L)
  380         CONTINUE
              IK = I1 - INC
              I1 = IK - INC
  390     CONTINUE 
          Q = (B - A)/2.0
          IF ( Q.EQ.0.0 )  Q = 1.0
          I1 = I0 + INC
          DO 400 L=1,M
              U(I0,L) = (Q*W(L,1,3) - W(L,0,2))/W(L,0,1)
              U(I1,L) = (Q*W(L,0,3) - W(L,1,2))/W(L,1,1)
  400     CONTINUE 
C
      END IF
C
C   ADD  W  TO  V  TO SATISFY THE BOUNDARY CONDITIONS
C
      IK = I1 + INC
      DO 430 K=2,N 
          IF ( MOD( K, 2 ).EQ.0 )  THEN
              DO 410 L=1,M
  410         U(IK,L) = U(IK,L) + U(I0,L)*W(L,K,1)
          ELSE
              DO 420 L=1,M
  420         U(IK,L) = U(IK,L) + U(I1,L)*W(L,K,1)
          END IF
          IK = IK + INC
  430 CONTINUE
      DO 440 L=1,M 
  440 U(I0,L) = U(I0,L)/2.0
      RETURN
      END
CDIR$  NOLIST
      SUBROUTINE FDER99( A, W, INC, JUMP, N, M, PERIOD )
C
C
C   PURPOSE
C
C       COMPUTES DERIVATIVES IN FOURIER SPECTRAL SPACE
C       (COMPATIBLE WITH ROUTINES  FFT99  AND  FFT991)
C
C   ARGUMENTS
C
C       DIMENSION   A(M*(N+2)), W(2*M) 
C
C       INPUT
C
C           A       ARRAY CONTAINING THE SPECTRAL COEFFICIENTS
C                   OF THE FUNCTIONS TO BE DIFFERENTIATED
C
C           W       WORK SPACE OF LENGTH AT LEAST  2*M
C
C           INC     STORAGE INCREMENT BETWEEN SUCCESSIVE
C                   ELEMENTS IN EACH INPUT VECTOR
C
C           JUMP    STORAGE INCREMENT BETWEEN THE STARTING 
C                   LOCATIONS OF SUCCESSIVE INPUT VECTORS
C
C           N       ORDER OF THE TRANSFORMS
C
C           M       NUMBER OF FUNCTIONS TO BE DIFFERENTIATED
C
C           PERIOD  PERIOD OF THE FUNCTIONS IN  X
C                   (IF ZERO,  PERIOD = 2*PI  IS ASSUMED)
C
C       NOTE:   A, INC, JUMP, N,  AND  M  MUST BE THE SAME AS IN THE 
C       CALL TO  FFT99  OR  FFT991  WHICH COMPUTED THE COEFFICIENTS
C
C       OUTPUT
C
C           A       CONTAINS THE SPECTRAL COEFFICIENTS OF THE DERIVATIVE
C
C   LANGUAGE    FORTRAN 77
C
C   HISTORY     WRITTEN BY SCOTT R. FULTON IN MAY 1983
C
C
      REAL  A(N), W(M,2), PERIOD
      INTEGER  INC, JUMP
      INTEGER  II, IR, J, K
      REAL  FACTOR, SCALE
C
C   SET UP THE SCALING FOR THE DERIVATIVES
C
      IF ( PERIOD.EQ.0.0 )  THEN
          SCALE = 1.0
      ELSE
          SCALE = 2.0*ACOS( -1.0 )/PERIOD
      END IF
C
C   SET INDEXING FOR REAL AND IMAGINARY PARTS OF SPECTRAL COEFFICIENTS
C
      IR = 1 - JUMP
      II = IR + INC
C
C   DO THE DERIVATIVES
C
      DO 20 K=0,N/2
          FACTOR = K*SCALE
CDIR$     IVDEP
          DO 10 J=1,M
              W(J,1) = A(IR+J*JUMP)
              W(J,2) = A(II+J*JUMP)
              A(IR+J*JUMP) = -FACTOR*W(J,2)
              A(II+J*JUMP) = +FACTOR*W(J,1)
   10     CONTINUE 
          IR = II + INC
          II = IR + INC
   20 CONTINUE
      RETURN
      END
      SUBROUTINE FSOP99( A, W, TFAX, INC, JUMP, N, M, PERIOD, ND, NS )
C
C
C   PURPOSE
C
C       COMPUTES OPERATIONS IN FOURIER SPECTRAL SPACE
C       (COMPATIBLE WITH ROUTINES  FFT99  AND  FFT991)
C
C   DEFINITION OF OPERATIONS 
C
C       THE INPUT TO THIS ROUTINE (A) IS ASSUMED TO CONTAIN THE FOURIER
C       SPECTRAL COEFFICIENTS OF A SET OF PERIODIC FUNCTIONS  F-SUB-J(X)
C       (J=1,...,M) AS COMPUTED BY  FFT99  OR  FFT991.  THE OUTPUT (A)
C       CONSISTS OF THE CORRESPONDING SPECTRAL COEFFICIENTS OF THE
C       FUNCTIONS AFTER THE OPERATIONS REQUESTED BY  ND  AND  NS:
C
C       DIFFERENTIATION (ND.GT.0):
C
C           DIFFERENTIATE EACH FUNCTION WITH RESPECT TO  X,  ND  TIMES
C
C       INTEGRATION (ND.LT.0):
C
C           INTEGRATE EACH FUNCTION WITH RESPECT TO  X,  ABS(ND)  TIMES
C           (EACH ZERO-ORDER COEFFICIENT IS ASSUMED ZERO ON INPUT SO 
C           THAT THE INTEGRAL IS PERIODIC, AND IS SET EQUAL TO ZERO
C           ON OUTPUT TO ESTABLISH THE CONSTANT OF INTEGRATION)
C
C       SHIFT OF FUNCTION VALUES (NS.NE.0):
C
C           PHASE SHIFT THE SPECTRAL COEFFICIENTS TO OBTAIN THE
C           CORRESPONDING SPECTRAL COEFFICIENTS OF THE FUNCTIONS
C           F-SUB-J(X - NS*DX/2)  WHERE  DX = PERIOD/N
C
C   ARGUMENTS
C
C       DIMENSION   A(M*(N+2)), W(2*M), TFAX(4*N)
C
C       INPUT
C
C           A       ARRAY CONTAINING THE INPUT SPECTRAL COEFFICIENTS 
C
C           W       WORK SPACE OF LENGTH AT LEAST  2*M
C
C           TFAX    TRIG FUNCTION VALUES COMPUTED BY THE ROUTINE  FSOPFX
C
C           INC     STORAGE INCREMENT BETWEEN SUCCESSIVE
C                   ELEMENTS IN EACH INPUT VECTOR
C
C           JUMP    STORAGE INCREMENT BETWEEN THE STARTING 
C                   LOCATIONS OF SUCCESSIVE INPUT VECTORS
C
C           N       ORDER OF THE TRANSFORMS
C
C           M       NUMBER OF FUNCTIONS TO BE OPERATED ON
C
C           PERIOD  PERIOD OF THE FUNCTIONS IN  X
C                   (IF ZERO,  PERIOD = 2*PI  IS ASSUMED)
C
C           ND      NUMBER OF DERIVATIVES TO BE COMPUTED
C                   (NEGATIVE FOR INTEGRALS, ZERO FOR NEITHER)
C
C           NS      NUMBER OF SHIFTS TO BE PERFORMED
C                   (ZERO FOR NO SHIFTS)
C
C       NOTE:   A, INC, JUMP, N,  AND  M  MUST BE THE SAME AS IN THE 
C       CALL TO  FFT99  OR  FFT991  WHICH COMPUTED THE COEFFICIENTS
C
C       OUTPUT
C
C           A       CONTAINS THE NEW SPECTRAL COEFFICIENTS 
C
C   LANGUAGE    FORTRAN 77
C
C   HISTORY     WRITTEN BY SCOTT R. FULTON IN FEBRUARY 1983
C
C
      REAL  A(N), W(M,2), TFAX(2,N), PERIOD
      INTEGER  INC, JUMP, ND, NS 
      INTEGER  II, IR, J, K, L, NBY2, N2
      REAL  COSFAC, FACTOR, SCALE, SINFAC
C
C   SET UP THE SCALING FOR THE DERIVATIVES OR INTEGRALS
C
      N2 = 2*N
      IF ( ND.EQ.0 .AND. MOD( NS, N2 ).EQ.0 )  RETURN
      IF ( ND.EQ.0 .OR. PERIOD.EQ.0.0 )  THEN
          SCALE = 1.0
      ELSE
          SCALE = 2.0*ACOS( -1.0 )/PERIOD
      END IF
C
C   SET INDEXING FOR REAL AND IMAGINARY PARTS OF SPECTRAL COEFFICIENTS
C
      IR = 1 - JUMP
      II = IR + INC
C
C   DO THE DERIVATIVES, INTEGRALS, AND/OR SHIFTS 
C
      NBY2 = N/2
      DO 20 K=0,NBY2
          IF ( ND.NE.0 )  THEN
              IF ( K.EQ.0 )  THEN
                  FACTOR = 0.0
              ELSE 
                  FACTOR = (K*SCALE)**ABS( ND )
                  IF ( ND.LT.0 )  FACTOR = 1.0/FACTOR
              END IF
          ELSE
              FACTOR = 1.0
          END IF
          L = NBY2*ND - K*NS 
          L = MOD( L, N2  )
          IF ( L.LT.0 )  L = L + N2
          COSFAC = FACTOR*TFAX(1,L+1)
          SINFAC = FACTOR*TFAX(2,L+1)
CDIR$     IVDEP
          DO 10 J=1,M
              W(J,1) = A(IR+J*JUMP)
              W(J,2) = A(II+J*JUMP)
              A(IR+J*JUMP) = COSFAC*W(J,1) - SINFAC*W(J,2) 
              A(II+J*JUMP) = SINFAC*W(J,1) + COSFAC*W(J,2) 
   10     CONTINUE 
          IR = II + INC
          II = IR + INC
   20 CONTINUE
      RETURN
      END
      SUBROUTINE FSOPFX( N, TFAX )
C
C
C   PURPOSE
C
C       COMPUTES TRIGONOMETRIC FACTORS FOR USE BY  FSOP99
C
C   ARGUMENTS
C
C       DIMENSION   TFAX(4*N)
C
C       INPUT
C
C           N       ORDER OF THE TRANSFORMS (AS IN FSOP99) 
C
C       OUTPUT
C
C           TFAX    CONTAINS THE TRIGONOMETRIC FACTORS NEEDED BY  FSOP99
C
C
      INTEGER  N, L
      REAL  TFAX(2,N), PIBYN 
C
      IF ( N.LE.0 )  RETURN
      PIBYN = ACOS( -1.0 )/N 
      DO 10 L=0,2*N-1
          TFAX(1,L+1) = COS( L*PIBYN ) 
          TFAX(2,L+1) = SIN( L*PIBYN ) 
   10 CONTINUE
      RETURN
      END
C
C
C
      SUBROUTINE SINTRAN(A,AW,WORK,TRIGS,IFAX,N,N2,ISGN)
C **********************************************************
C     THIS ROUTINE PERFORMS THE SINGLE SINE TRANSFORM
C
C  USAGE:
C      CALL FFTFAX(N2,IFAX,TRIGS )
C        before you use SINTRAN and COSTRAN
C
C  REQUIRED LIB.
C      FFT99 AND FFTFAX (AVAILABLE FROM H.- C. KUO)
C
C  INPUT: 
C            N  :  NO OF VALUES IN PHYSICAL OR SPECTRAL SPACE 
C        A(0:N) :  ARRAY FOR THE SINE TRANSFORM 
C         ISGN  :  -1     PHYSICAL TO SPECTRAL
C         ISGN  :  +1     SPECTRAL TO PHYSICAL 
C           N2  :  2*N
C WORKK ARRAYS  :  IFAX(13),WORK((N2+1)),TRIGS(3*N2/2+1)  
C                  AW(-1:N2)
C
C  OUTPUT:
C        A(0:N) :  ARRAY AFTER THE SINE TRANSFORM 
C     AW(-1:N2) :  WORK ARRAY CONTAINS THE INFOS OF A(0:N)
C
C  TO PHYSICALLY INTERPRET THE SPECTRAL COEFFICIENT, 
C  A FACTOR OF -2 SHOULD BE MULTIPLIED TO A(0:N)
C  THIS FACTOR COMES FROM (2i) * (0.0 + ia(I)) 
C
C **********IF ISGN = -1, AW(-1:N2) CONTAINS VALUES AS FOLLOWS
C        0.0  A(0)   0.0  A(1)   0.0  A(2)...............0.0   A(N)
C     AW(-1) AW(0) AW(1) AW(2) AW(3) AW(4)..........AW(N2-1) AW(N2)
C
C **********IF ISGN = +1, AW(-1:N2) CONTAINS VALUES AS FOLLOWS
C      -A(1)  A(0)  A(1)....A(N) -A(N-1) -A(N-2).......-A(1)  -A(0)  
C     AW(-1) AW(0) AW(1)...AW(N) AW(N+1) AW(N+2)....AW(N2-1) AW(N2)
C
C  THIS ROUTINE IS INEFFICIENT IN A FACTOR OF TWO!!!
C  WRITTEN BY H.C. KUO MARCH 15 1991
C***********************************************************************
      REAL A(0:N),AW(-1:N2)
      REAL IFAX(13),WORK(N2+1),TRIGS(3*N2/2+1)
C SET UP FOR THE FFT99 ROUTINE
C      CALL FFTFAX(N2,IFAX,TRIGS )
      INC=1
      JUMP=N2+2
C
      IF(ISGN .EQ. -1) THEN
C  PHYSICAL TO SPECTRAL TRANSFORM
         DO 10 I=0,N
            AW(I)    = A(I)
            AW(N2-I) = A(I)*(-1.0)
 10      CONTINUE
         AW(-1) = AW(N2-1) 
C
         CALL FFT99(AW,WORK,TRIGS,IFAX,INC,JUMP,N2,1,ISGN)
C
         DO 20 I=0,N
            II   = 2*I 
            A(I) = AW(II)
 20      CONTINUE      
      ENDIF
C
      IF(ISGN .EQ. +1) THEN
C  SPECTRAL TO PHYSICAL TRANSFORM
         DO 30 I=0,N
            II = 2*I
            AW(II)   = A(I)
            AW(II-1) = 0.0 
 30      CONTINUE
C
         CALL FFT99(AW,WORK,TRIGS,IFAX,INC,JUMP,N2,1,ISGN)
C
         DO 40 I=0,N
            A(I) = AW(I)
 40      CONTINUE      
      ENDIF
C
      RETURN
      END
C
      SUBROUTINE COSTRAN(A,AW,WORK,TRIGS,IFAX,N,N2,ISGN)
C **********************************************************
C     THIS ROUTINE PERFORMS THE SINGLE COSINE TRANSFORM
C
C  INPUT: 
C            N  :  NO OF VALUES IN PHYSICAL OR SPECTRAL SPACE 
C        A(0:N) :  ARRAY FOR THE COSINE TRANSFORM 
C         ISGN  :  -1     PHYSICAL TO SPECTRAL
C         ISGN  :  +1     SPECTRAL TO PHYSICAL 
C           N2  :  2*N
C WORKK ARRAYS  :  IFAX(13),WORK((N2+1)),TRIGS(3*N2/2+1)  
C                  AW(-1:N2)
C
C  OUTPUT:
C        A(0:N) :  ARRAY AFTER THE COSINE TRANSFORM 
C     AW(-1:N2) :  WORK ARRAY CONTAINS THE INFOS OF A(0:N)
C
C  TO PHYSICALLY INTERPRET THE SPECTRAL COEFFICIENT, 
C  A FACTOR OF 2 SHOULD BE MULTIPLIED TO A(0:N)
C  THIS FACTOR COMES FROM (2) * (a(I) + 0.0) 
C
C **********IF ISGN = -1, AW(-1:N2) CONTAINS VALUES AS FOLLOWS
C       A(0)  0.0   A(1)  0.0   A(2)  0.0 ..............A(N)  0.0   
C     AW(-1) AW(0) AW(1) AW(2) AW(3) AW(4)..........AW(N2-1) AW(N2)
C
C **********IF ISGN = +1, AW(-1:N2) CONTAINS VALUES AS FOLLOWS
C       A(1)  A(0)  A(1)....A(N)  A(N-1)  A(N-2)....... A(1)   A(0)  
C     AW(-1) AW(0) AW(1)...AW(N) AW(N+1) AW(N+2)....AW(N2-1) AW(N2)
C
C  THIS ROUTINE IS INEFFICIENT IN A FACTOR OF TWO!!!
C  WRITTEN BY H.C. KUO MARCH 15 1991
C***********************************************************************
      REAL A(0:N),AW(-1:N2)
      REAL IFAX(13),WORK(N2+1),TRIGS(3*N2/2+1)
C SET UP FOR THE FFT99 ROUTINE
C     CALL FFTFAX(N2,IFAX,TRIGS )
      INC=1
      JUMP=N2+2
C
      IF(ISGN .EQ. -1) THEN
C  PHYSICAL TO SPECTRAL TRANSFORM
         DO 10 I=0,N
            AW(I)    = A(I)
            AW(N2-I) = A(I)
 10      CONTINUE
         AW(-1) = AW(N2-1) 
C
         CALL FFT99(AW,WORK,TRIGS,IFAX,INC,JUMP,N2,1,ISGN)
C
         DO 20 I=0,N
            II   = 2*I - 1 
            A(I) = AW(II)
 20      CONTINUE      
      ENDIF
C
      IF(ISGN .EQ. +1) THEN
C  SPECTRAL TO PHYSICAL TRANSFORM
         DO 30 I=0,N
            II = 2*I
            AW(II)   = 0.0
            AW(II-1) = A(I) 
 30      CONTINUE
C
         CALL FFT99(AW,WORK,TRIGS,IFAX,INC,JUMP,N2,1,ISGN)
C
         DO 40 I=0,N
            A(I) = AW(I)
 40      CONTINUE      
      ENDIF
C
      RETURN
      END
C
      SUBROUTINE DERSC(A,N,DOX,ICASE)
C **********************************************************
C   THIS ROUTINE PERFORMS THE DERIVATIVE IN THE SPECTRAL SPACE
C   MORE PRECISELY, THIS ROUTINE ONLY TIMES THE WAVE NUMBER
C   TO THE SPECTRAL COEFFICIENT
C
C  INPUT: 
C            N  :  NO OF VALUES IN SPECTRAL SPACE 
C        A(0:N) :  ARRAY IN SPECTRAL SPACE 
C          DOX  :  LENGTH OF PHYSICAL DOMAIN
C         ICASE :  +1     DERIVATIVE OF COSINE FUN.
C                  -1     DERIVATIVE OF SINE   FUN. 
C                  Because
C                    ik(a + ib) = -kb + ika
C
C  OUTPUT:
C        A(0:N) :  ARRAY OF SPECTRAL COEFF. AFTER THE 
C                  MULTIPLICATION OF  WAVE NUMBER 
C                   A(I) = A(I)*FLOAT(I)*FLOAT(ICASE)*PI/DOX
C                   for    I=0,....N
C                  ICASE= -1  or ICASE = +1
C
C       TO GET THE DERIVATIVE OF A SINE OR COSINE EXPANSION
C       WE SHOULD FOLLOW THE FOLLOWING PROCEDURE:
C        (1) CALL SINTRAN (OR COSTRAN)   To get spectral coeff. A
C        (2) CALL DERSC(A,N,DOX, ICASE)
C        (3) CALL COSTRAN (OR SINTRAN)   To get physical values A
C                                  This A is the derivative of input A
C
C***********************************************************
      REAL A(0:N),PI
      PI = ACOS(-1.0)
C
      DO 10 I=0,N
         A(I) = A(I)*FLOAT(I)*FLOAT(ICASE)*PI/DOX
 10   CONTINUE
      RETURN
      END
C**************************************************
C PACKAGE OLDFFTPK       DOCUMENTATION OF USER ENTRIES IS INTERSPERSED
C                        WITH SOURCE CODE BELOW. 
C
C
C LATEST REVISION        FEBRUARY 1978 (VERSION 2)
C
C
C PURPOSE                OLDFFTPK IS A VERY OLD, VERY SLOW VERSION OF
C                        NCAR PACKAGE FFTPACK.  OLDFFTPK IS TARGETED FOR
C                        DELETION, AND POTENTIAL USERS ARE ENCOURAGED
C                        TO USE FFTPACK INSTEAD. 
C
C
C USAGE                  USER ENTRY POINTS ARE ...
C
C                            RFFTI   RFFTF   RFFTB
C                            EZFFTF  EZFFTB  SINTI
C                            SINT    COSTI   COST
C                            SINQI   SINQF   SINQB
C                            COSQI   COSQF   COSQB
C                            CFFTI   CFFTF   CFFTB
C
C
C SPECIAL CONDITIONS     SEE 'PURPOSE' ABOVE.
C
C
C I/O                    NONE
C
C
C PRECISION              SINGLE
C
C
C REQUIRED LIBRARY       NONE
C FILES
C
C
C LANGUAGE               FORTRAN
C
C
C HISTORY                THIS PRESENT VERSION 2 WAS DEVELOPED IN 1978
C                        AT NCAR BY PAUL SWARZTRAUBER OF THE ADVANCED
C                        METHODS GROUP.  IT IS SUPERSEDED BY AT LEAST
C                        TWO VERSIONS OF FFTPACK.
C
C PORTABILITY            FORTRAN 66.  PORT NCAR SOFTWARE PACKAGE
C                        FFTPACK INSTEAD.
C
C
C REFERENCES             NONE
C **********************************************************************
      SUBROUTINE EZFFTI (N,WSAVE)
      DIMENSION       WSAVE(1)
C
      IF (N .LE. 2) RETURN
      NS2 = N/2
      MODN = N-NS2-NS2
      IF (MODN .NE. 0) GO TO 101
      IW1 = N+1
      CALL RFFTI (N,WSAVE(IW1))
      RETURN
  101 IW1 = N+N+1
      CALL CFFTI (N,WSAVE(IW1))
      RETURN
      END
      SUBROUTINE EZFFTF (N,R,AZERO,A,B,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE EZFFTF(N,R,AZERO,A,B,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE EZFFTF COMPUTES THE FOURIER COEFFICIENTS OF A REAL
C     PERODIC SEQUENCE (FOURIER ANALYSIS). THE TRANSFORM IS DEFINED
C     BELOW AT OUTPUT PARAMETERS AZERO,A AND B. EZFFTF IS A SIMPLIFIED
C     VERSION OF RFFTF. IT IS NOT AS FAST AS RFFTF SINCE SCALING
C     AND INITIALIZATION ARE COMPUTED FOR EACH TRANSFORM. THE REPEATED
C     INITIALIZATION CAN BE SUPPRESSED BY REMOVEING THE STATMENT
C     ( CALL EZFFTI(N,WSAVE) ) FROM BOTH EZFFTF AND EZFFTB AND INSERTING
C     IT AT THE APPROPRIATE PLACE IN YOUR PROGRAM.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R. EZFFTF IS ABOUT TWICE AS FAST
C             FOR EVEN N AS IT IS FOR ODD N. ALSO EZFFTF IS MORE
C             EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES.
C
C     R       A REAL ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE
C             TO BE TRANSFORMED. R IS NOT DESTROYED.
C
C     WSAVE   A WORK ARRAY WHOSE LENGTH DEPENDS ON WHETHER N IS EVEN OR
C             ODD. 
C
C                  IF N IS EVEN 3.5*N+15 LOCATIONS ARE REQUIRED
C                  IF N IS ODD  6*N+15   LOCATIONS ARE REQUIRED
C
C
C     OUTPUT PARAMETERS
C
C     AZERO   THE SUM FROM I=1 TO I=N OF R(I)/N
C
C     A,B     FOR N EVEN DEFINE KMAX=N/2
C             FOR N ODD  DEFINE KMAX=(N-1)/2
C
C             THEN FOR  K=1,...,KMAX
C
C                  A(K) EQUALS THE SUM FROM I=1 TO I=N OF
C
C                       2./N*R(I)*COS(K*(I-1)*2*PI/N)
C
C                  B(K) EQUALS THE SUM FROM I=1 TO I=N OF
C
C                       2./N*R(I)*SIN(K*(I-1)*2*PI/N)
C
C
      DIMENSION       R(1)       ,A(1)       ,B(1)       ,WSAVE(1)
C
      IF (N .GT. 1) GO TO 101
      AZERO = R(1) 
      RETURN
  101 IF (N .GT. 2) GO TO 102
      AZERO = .5*(R(1)+R(2)) 
      A(1) = .5*(R(1)-R(2))
      RETURN
  102 NS2 = N/2
C
C     TO SUPRESS REPEATED INITIALIZATION REMOVE THE FOLLOWING STATMENT
C     ( CALL EZFFTI(N,WSAVE)) FROM BOTH THIS PROGRAM AND EZFFTB AND
C     INSERT IT AT THE APPROPRIATE PLACE IN YOUR PROGRAM.
C
      CALL EZFFTI (N,WSAVE)
C
      MODN = N-NS2-NS2
      IF (MODN .NE. 0) GO TO 105
      IW1 = N+1
      DO 103 I=1,N 
         WSAVE(I) = R(I)
  103 CONTINUE
      CALL RFFTF (N,WSAVE,WSAVE(IW1))
      CF = 1./FLOAT(N)
      AZERO = .5*CF*WSAVE(1) 
      A(NS2) = .5*CF*WSAVE(2)
      B(NS2) = 0.
      NS2M = NS2-1 
      DO 104 I=1,NS2M
         A(I) = CF*WSAVE(2*I+1)
         B(I) = CF*WSAVE(2*I+2)
  104 CONTINUE
      RETURN
  105 IW1 = N+N+1
      DO 106 I=1,N 
         WSAVE(2*I-1) = R(I) 
         WSAVE(2*I) = 0.
  106 CONTINUE
      CALL CFFTF (N,WSAVE,WSAVE(IW1))
      CF = 2./FLOAT(N)
      AZERO = .5*CF*WSAVE(1) 
      NM1S2 = (N-1)/2
      DO 107 I=1,NM1S2
         A(I) = CF*WSAVE(2*I+1)
         B(I) = -CF*WSAVE(2*I+2)
  107 CONTINUE
      RETURN
      END
      SUBROUTINE EZFFTB (N,R,AZERO,A,B,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE EZFFTB(N,R,AZERO,A,B,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE EZFFTB COMPUTES A REAL PERODIC SEQUENCE FROM ITS
C     FOURIER COEFFICIENTS (FOURIER SYNTHESIS). THE TRANSFORM IS
C     DEFINED BELOW AT OUTPUT PARAMETER R. EZFFTB IS A SIMPLIFIED
C     VERSION OF RFFTB. IT IS NOT AS FAST AS RFFTB SINCE SCALING AND 
C     INITIALIZATION ARE COMPUTED FOR EACH TRANSFORM. THE REPEATED
C     INITIALIZATION CAN BE SUPPRESSED BY REMOVEING THE STATMENT
C     ( CALL EZFFTI(N,WSAVE) ) FROM BOTH EZFFTF AND EZFFTB AND INSERTING
C     IT AT THE APPROPRIATE PLACE IN YOUR PROGRAM.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R. EZFFTB IS ABOUT TWICE AS FAST
C             FOR EVEN N AS IT IS FOR ODD N. ALSO EZFFTB IS MORE
C             EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES.
C
C     AZERO   THE CONSTANT FOURIER COEFFICIENT
C
C     A,B     ARRAYS WHICH CONTAIN THE REMAINING FOURIER COEFFICIENTS
C             THESE ARRAYS ARE NOT DESTROYED.
C
C             THE LENGTH OF THESE ARRAYS DEPENDS ON WHETHER N IS EVEN OR
C             ODD. 
C
C             IF N IS EVEN N/2    LOCATIONS ARE REQUIRED
C             IF N IS ODD (N-1)/2 LOCATIONS ARE REQUIRED
C
C     WSAVE   A WORK ARRAY WHOSE LENGTH DEPENDS ON WHETHER N IS EVEN OR
C             ODD. 
C
C                  IF N IS EVEN 3.5*N+15 LOCATIONS ARE REQUIRED
C                  IF N IS ODD  6*N+15   LOCATIONS ARE REQUIRED
C
C
C     OUTPUT PARAMETERS
C
C     R       IF N IS EVEN DEFINE KMAX=N/2
C             IF N IS ODD  DEFINE KMAX=(N-1)/2
C
C             THEN FOR I=1,...,N
C
C                  R(I)=AZERO PLUS THE SUM FROM K=1 TO K=KMAX OF
C
C                  A(K)*COS(K*(I-1)*2*PI/N)+B(K)*SIN(K*(I-1)*2*PI/N) 
C
C     ********************* COMPLEX NOTATION **************************
C
C             FOR J=1,...,N
C
C             R(J) EQUALS THE SUM FROM K=-KMAX TO K=KMAX OF
C
C                  C(K)*EXP(I*K*(J-1)*2*PI/N)
C
C             WHERE
C
C                  C(K) = .5*CMPLX(A(K),-B(K))   FOR K=1,...,KMAX
C
C                  C(-K) = CONJG(C(K)) 
C
C                  C(0) = AZERO
C
C                       AND I=SQRT(-1) 
C
C     *************** AMPLITUDE - PHASE NOTATION ***********************
C
C             FOR I=1,...,N
C
C             R(I) EQUALS AZERO PLUS THE SUM FROM K=1 TO K=KMAX OF
C
C                  ALPHA(K)*COS(K*(I-1)*2*PI/N+BETA(K))
C
C             WHERE
C
C                  ALPHA(K) = SQRT(A(K)*A(K)+B(K)*B(K))
C
C                  COS(BETA(K))=A(K)/ALPHA(K)
C
C                  SIN(BETA(K))=-B(K)/ALPHA(K)
C
      DIMENSION       R(1)       ,A(1)       ,B(1)       ,WSAVE(1)
C
      IF (N .GT. 1) GO TO 101
      R(1) = AZERO 
      RETURN
  101 IF (N .GT. 2) GO TO 102
      R(1) = AZERO+A(1)
      R(2) = AZERO-A(1)
      RETURN
  102 NS2 = N/2
C
C     TO SUPRESS REPEATED INITIALIZATION REMOVE THE FOLLOWING STATMENT
C     ( CALL EZFFTI(N,WSAVE)) FROM BOTH THIS PROGRAM AND EZFFTF AND
C     INSERT IT AT THE APPROPRIATE PLACE IN YOUR PROGRAM.
C
      CALL EZFFTI (N,WSAVE)
C
      MODN = N-NS2-NS2
      IF (MODN .NE. 0) GO TO 104
      IW1 = N+1
      NS2M = NS2-1 
      DO 103 I=1,NS2M
         R(2*I+1) = .5*A(I)
         R(2*I+2) = .5*B(I)
  103 CONTINUE
      R(1) = AZERO 
      R(2) = A(NS2)
      CALL RFFTB (N,R,WSAVE(IW1))
      RETURN
  104 IW1 = N+N+1
      NM1S2 = (N-1)/2
      DO 105 I=1,NM1S2
         IC = N-I
         WSAVE(2*I+1) = A(I) 
         WSAVE(2*I+2) = -B(I)
         WSAVE(2*IC+1) = A(I)
         WSAVE(2*IC+2) = B(I)
  105 CONTINUE
      WSAVE(1) = AZERO+AZERO 
      WSAVE(2) = 0.
      CALL CFFTB (N,WSAVE,WSAVE(IW1))
      DO 106 I=1,N 
         R(I) = .5*WSAVE(2*I-1)
  106 CONTINUE
      RETURN
      END
      SUBROUTINE RFFTI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE RFFTI(N,WSAVE)
C
C       ****************************************************************
C
C     SUBROUTINE RFFTI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     BOTH RFFTF AND RFFTB. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED. N MUST BE
C             EVEN 
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2.5*N+15.
C             THE SAME WORK ARRAY CAN BE USED FOR BOTH RFFTF AND RFFTB
C             AS LONG AS N REMAINS UNCHANGED. DIFFERENT WSAVE ARRAYS 
C             ARE REQUIRED FOR DIFFERENT VALUES OF N. THE CONTENTS OF
C             WSAVE MUST NOT BE CHANGED BETWEEN CALLS OF RFFTF OR RFFTB.
C
      DIMENSION       WSAVE(1)
C
      NS2 = N/2
      NQM = (NS2-1)/2
      TPI = 8.*ATAN(1.)
      DT = TPI/FLOAT(N)
      DC = COS(DT) 
      DS = SIN(DT) 
      WSAVE(1) = DC
      WSAVE(NS2-1) = DS
      IF (NQM .LT. 2) GO TO 102
      DO 101 K=2,NQM
         KC = NS2-K
         WSAVE(K) = DC*WSAVE(K-1)-DS*WSAVE(KC+1) 
         WSAVE(KC) = DS*WSAVE(K-1)+DC*WSAVE(KC+1)
  101 CONTINUE
  102 IW1 = NS2+1
      CALL CFFTI (NS2,WSAVE(IW1))
      RETURN
      END
      SUBROUTINE RFFTF (N,R,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE RFFTF(N,R,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE RFFTF COMPUTES THE FOURIER COEFFICIENTS OF A REAL
C     PERODIC SEQUENCE (FOURIER ANALYSIS). THE TRANSFORM IS DEFINED
C     BELOW AT OUTPUT PARAMETER R.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C             N MAY CHANGE SO LONG AS DIFFERENT WORK ARRAYS ARE PROVIDED
C
C     R       A REAL ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE
C             TO BE TRANSFORMED
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2.5*N+15
C             IN THE PROGRAM THAT CALLS RFFTF. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE RFFTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY RFFTF AND RFFTB.
C
C
C     OUTPUT PARAMETERS
C
C     R       FOR K=2,...,N/2
C
C                  R(2*K-1)= THE SUM FROM I=1 TO I=N OF
C
C                       2.*R(I)*COS((K-1)*(I-1)*2*PI/N)
C
C                  R(2*K)= THE SUM FROM I=1 TO I=N OF
C
C                       2.*R(I)*SIN((K-1)*(I-1)*2*PI/N)
C
C             ALSO 
C
C                  R(1)= THE SUM FROM I=1 TO I=N OF 2.*R(I)
C
C                  R(2)= THE SUM FROM I=1 TO I=N OF 2.*(-1)**(I+1)*R(I)
C
C      *****  NOTE 
C                  THIS TRANSFORM IS UNNORMALIZED SINCE A CALL OF RFFTF
C                  FOLLOWED BY A CALL OF RFFTB WILL MULTIPLY THE INPUT
C                  SEQUENCE BY 2*N.
C
C     WSAVE   CONTAINS RESULTS WHICH MUST NOT BE DESTROYED BETWEEN
C             CALLS OF RFFTF OR RFFTB. 
C
C
      DIMENSION       R(2,1)     ,WSAVE(1)
C
      IF (N .GT. 2) GO TO 101
      R1 = 2.*(R(1,1)+R(2,1))
      R(2,1) = 2.*(R(1,1)-R(2,1))
      R(1,1) = R1
      RETURN
  101 IW1 = N/2+1
      CALL RFFTF1 (N,R,WSAVE(IW1),WSAVE)
      RETURN
      END
      SUBROUTINE RFFTF1 (N,X,XH,W)
      DIMENSION       X(2,1)     ,XH(2,1)    ,W(1)
      NS2 = N/2
      NS2P2 = NS2+2
      NQ = NS2/2
      IPAR = NS2-NQ-NQ
      NQM = NQ
      IF (IPAR .EQ. 0) NQM = NQM-1
      NQP = NQM+1
      CALL CFFTF (NS2,X,XH)
      IF (NQP .LT. 2) GO TO 107
      DO 101 K=2,NQP
         KC = NS2P2-K
         XH(1,KC) = X(2,K)+X(2,KC)
         XH(2,KC) = X(1,KC)-X(1,K)
  101 CONTINUE
      DO 102 K=2,NQP
         KC = NS2P2-K
         XH(1,K) = X(1,K)+X(1,KC)
         XH(2,K) = X(2,K)-X(2,KC)
  102 CONTINUE
      DO 103 K=2,NQP
         KC = NS2P2-K
         X(1,KC) = W(K-1)*XH(1,KC)+W(KC-1)*XH(2,KC)
         X(2,KC) = W(K-1)*XH(2,KC)-W(KC-1)*XH(1,KC)
  103 CONTINUE
      DO 104 K=2,NQP
         KC = NS2P2-K
         XH(1,KC) = X(1,KC)
         XH(2,KC) = X(2,KC)
  104 CONTINUE
      DO 105 K=2,NQP
         KC = NS2P2-K
         X(1,KC) = XH(1,K)-XH(1,KC)
         X(2,KC) = XH(2,K)-XH(2,KC)
  105 CONTINUE
      DO 106 K=2,NQP
         KC = NS2P2-K
         X(1,K) = XH(1,K)+XH(1,KC)
         X(2,K) = -XH(2,K)-XH(2,KC)
  106 CONTINUE
      IF (IPAR .NE. 0) GO TO 108
  107 X(1,NQP+1) = X(1,NQP+1)+X(1,NQP+1)
      X(2,NQP+1) = X(2,NQP+1)+X(2,NQP+1)
  108 XHOLD1 = X(2,1)+X(1,1) 
      XHOLD2 = X(1,1)-X(2,1) 
      X(2,1) = XHOLD2+XHOLD2 
      X(1,1) = XHOLD1+XHOLD1 
      RETURN
      END
      SUBROUTINE RFFTB (N,R,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE RFFTB(N,R,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE RFFTB COMPUTES THE REAL PERODIC SEQUENCE FROM ITS
C     FOURIER COEFFICIENTS (FOURIER SYNTHESIS). THE TRANSFORM IS DEFINED
C     BELOW AT OUTPUT PARAMETER R.
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY R. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C             N MAY CHANGE SO LONG AS DIFFERENT WORK ARRAYS ARE PROVIDED
C
C     R       A REAL ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE
C             TO BE TRANSFORMED
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 2.5*N+15
C             IN THE PROGRAM THAT CALLS RFFTB. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE RFFTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY RFFTF AND RFFTB.
C
C
C     OUTPUT PARAMETERS
C
C     R       FOR I=1,...,N
C
C                  R(I)=X(1)+(-1)**(I+1)*X(2)
C
C                       PLUS THE SUM FROM K=2 TO K=N/2 OF
C
C                         2*R(2K-1)*COS((K-1)*(I-1)*2*PI/N)
C
C                        +2*R(2K)*SIN((K-1)*(I-1)*2*PI/N)
C
C      *****  NOTE 
C                  THIS TRANSFORM IS UNNORMALIZED SINCE A CALL OF RFFTF
C                  FOLLOWED BY A CALL OF RFFTB WILL MULTIPLY THE INPUT
C                  SEQUENCE BY 2*N.
C
C     WSAVE   CONTAINS RESULTS WHICH MUST NOT BE DESTROYED BETWEEN
C             CALLS OF RFFTB OR RFFTF. 
C
C
      DIMENSION       R(2,1)     ,WSAVE(1)
C
      IF (N .GT. 2) GO TO 101
      R1 = R(1,1)+R(2,1)
      R(2,1) = R(1,1)-R(2,1) 
      R(1,1) = R1
      RETURN
  101 IW1 = N/2+1
      CALL RFFTB1 (N,R,WSAVE(IW1),WSAVE)
      RETURN
      END
      SUBROUTINE RFFTB1 (N,X,XH,W)
      DIMENSION       X(2,1)     ,XH(2,1)    ,W(1)
      NS2 = N/2
      NS2P2 = NS2+2
      NQ = NS2/2
      IPAR = NS2-NQ-NQ
      NQM = NQ
      IF (IPAR .EQ. 0) NQM = NQM-1
      NQP = NQM+1
      XHOLD1 = X(1,1)-X(2,1) 
      X(1,1) = X(2,1)+X(1,1) 
      X(2,1) = XHOLD1
      IF (IPAR .NE. 0) GO TO 101
      X(1,NQP+1) = X(1,NQP+1)+X(1,NQP+1)
      X(2,NQP+1) = X(2,NQP+1)+X(2,NQP+1)
  101 IF (NQP .LT. 2) GO TO 108
      DO 102 K=2,NQP
         KC = NS2P2-K
         XH(1,K) = X(1,K)+X(1,KC)
         XH(2,K) = X(2,KC)-X(2,K)
  102 CONTINUE
      DO 103 K=2,NQP
         KC = NS2P2-K
         XH(1,KC) = X(1,K)-X(1,KC)
         XH(2,KC) = -X(2,K)-X(2,KC)
  103 CONTINUE
      DO 104 K=2,NQP
         KC = NS2P2-K
         X(1,KC) = XH(1,KC)
         X(2,KC) = XH(2,KC)
  104 CONTINUE
      DO 105 K=2,NQP
         KC = NS2P2-K
         XH(1,KC) = W(K-1)*X(1,KC)-W(KC-1)*X(2,KC)
         XH(2,KC) = W(K-1)*X(2,KC)+W(KC-1)*X(1,KC)
  105 CONTINUE
      DO 106 K=2,NQP
         KC = NS2P2-K
         X(1,K) = XH(1,K)-XH(2,KC)
         X(2,K) = XH(2,K)+XH(1,KC)
  106 CONTINUE
      DO 107 K=2,NQP
         KC = NS2P2-K
         X(1,KC) = XH(1,K)+XH(2,KC)
         X(2,KC) = XH(1,KC)-XH(2,K)
  107 CONTINUE
  108 CALL CFFTB (NS2,X,XH)
      RETURN
      END
      SUBROUTINE COSTI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE COSTI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE COSTI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     SUBROUTINE COST. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED. N MUST BE
C             ODD AND GREATER THAN 1.
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3*N+12.
C             DIFFERENT WSAVE ARRAYS ARE REQUIRED FOR DIFFERENT VALUES
C             OF N. THE CONTENTS OF WSAVE MUST NOT BE CHANGED BETWEEN
C             CALLS OF COST. 
C
      DIMENSION       WSAVE(1)
C
      IF (N .LE. 3) RETURN
      NM1 = N-1
      NS2 = NM1/2
      NS2M = NS2-1 
      IW1 = NS2+1
      PI = 4.*ATAN(1.)
      DT = PI/FLOAT(NM1)
      DCS = COS(DT)
      DSS = SIN(DT)
      WSAVE(1) = DSS+DSS
      WCK = DCS+DCS
      IF (NS2M .LT. 2) GO TO 102
      DO 101 K=2,NS2M
         WSAVE(K) = DSS*WCK+DCS*WSAVE(K-1)
         WCK = DCS*WCK-DSS*WSAVE(K-1)
  101 CONTINUE
  102 CALL RFFTI (NM1,WSAVE(IW1))
      RETURN
      END
      SUBROUTINE COST (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE COST(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE COST COMPUTES THE DISCRETE FOURIER COSINE TRANSFORM 
C     OF AN EVEN SEQUENCE X(I). THE TRANSFORM IS DEFINED BELOW AT OUTPUT
C     PARAMETER X. 
C
C     COST IS THE UNNORMALIZED INVERSE OF ITSELF SINCE A CALL OF COST
C     FOLLOWED BY ANOTHER CALL OF COST WILL MULTIPLY THE INPUT SEQUENCE
C     X BY 8*(N+1). THE TRANSFORM IS DEFINED BELOW AT OUTPUT PARAMETER X
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE COST MUST BE
C     INITIALIZED BY CALLING SUBROUTINE COSTI(N,WSAVE).
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE SEQUENCE X. N MUST BE ODD AND GREATER
C             THAN 1. THE METHOD IS MOST EFFICIENT WHEN N-1 IS A PRODUCT
C             OF SMALL PRIMES.
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3*N+15 
C             IN THE PROGRAM THAT CALLS COST. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE COSTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                X(I)= 2*X(1)+2*(-1)**(I+1)*X(N) 
C
C                  + THE SUM FROM K=2 TO K=N-1
C
C                    4*X(K)*COS((K-1)*(I-1)*PI/(N-1))
C
C                  A CALL OF COST FOLLOWED BY ANOTHER CALL OF
C                  COST WILL MULTIPLY THE SEQUENCE X BY 8(N+1)
C                  HENCE COST IS THE UNNORMALIZED INVERSE
C                  OF ITSELF.
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT BE 
C             DESTROYED BETWEEN CALLS OF COST.
C
      DIMENSION       X(1)       ,WSAVE(1)
C
      NM1 = N-1
      NP1 = N+1
      NS2 = NM1/2
      IW1 = NS2+1
      IF (N .GT. 3) GO TO 101
      X1PX3 = X(1)+X(3)
      TX13 = X1PX3+X1PX3
      FX2 = 4.*X(2)
      X(2) = 2.*(X(1)-X(3))
      X(1) = TX13+FX2
      X(3) = TX13-FX2
      RETURN
  101 C1 = X(1)-X(N)
      DO 102 K=2,NS2
         KC = NM1-K
         KS = NS2-K
         C1 = C1+WSAVE(KS+1)*(X(K)-X(KC+2))
  102 CONTINUE
      C1 = C1+C1
      X(1) = X(1)+X(N)
      DO 103 K=2,NS2
         KC = NP1-K
         T1 = X(K)+X(KC)
         T2 = WSAVE(K-1)*(X(K)-X(KC))
         X(K) = T1-T2
         X(KC) = T1+T2
  103 CONTINUE
      X(NS2+1) = X(NS2+1)+X(NS2+1)
      CALL RFFTF (NM1,X,WSAVE(IW1))
      CN = X(2)
      X(2) = C1
      DO 104 I=4,NM1,2
         X(I) = X(I)+X(I-2)
  104 CONTINUE
      X(N) = CN
      RETURN
      END
      SUBROUTINE SINTI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE SINTI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE SINTI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     SUBROUTINE SINT. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED. N MUST BE
C             ODD. 
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3*N+18.
C             DIFFERENT WSAVE ARRAYS ARE REQUIRED FOR DIFFERENT VALUES
C             OF N. THE CONTENTS OF WSAVE MUST NOT BE CHANGED BETWEEN
C             CALLS OF SINT. 
C
      DIMENSION       WSAVE(1)
C
      IF (N .LE. 1) RETURN
      NP1 = N+1
      NS2 = NP1/2
      NS2M = NS2-1 
      IW1 = NS2+1
      PI = 4.*ATAN(1.)
      DT = PI/FLOAT(NP1)
      DCS = COS(DT)
      DSS = SIN(DT)
      WSAVE(1) = DSS+DSS
      WCK = DCS+DCS
      IF (NS2M .LT. 2) GO TO 102
      DO 101 K=2,NS2M
         WSAVE(K) = DSS*WCK+DCS*WSAVE(K-1)
         WCK = DCS*WCK-DSS*WSAVE(K-1)
  101 CONTINUE
  102 CALL RFFTI (NP1,WSAVE(IW1))
      RETURN
      END
      SUBROUTINE SINT (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE SINT(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE SINT COMPUTES THE DISCRETE FOURIER SINE TRANSFORM
C     OF AN ODD SEQUENCE X(I). THE TRANSFORM IS DEFINED BELOW AT
C     OUTPUT PARAMETER X.
C
C     SINT IS THE UNNORMALIZED INVERSE OF ITSELF SINCE A CALL OF SINT
C     FOLLOWED BY ANOTHER CALL OF SINT WILL MULTIPLY THE INPUT SEQUENCE
C     X BY 8*(N+1).
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE SINT MUST BE
C     INITIALIZED BY CALLING SUBROUTINE SINTI(N,WSAVE).
C
C     INPUT PARAMETERS
C
C     N       N IS THE LENGTH OF X. N MUST BE ODD AND THE METHOD IS
C             MOST EFFICIENT WHEN N+1 IS A PRODUCT OF SMALL PRIMES
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C                   ************IMPORTANT*************
C
C                   X MUST BE DIMENSIONED AT LEAST N+1
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3N+18
C             IN THE PROGRAM THAT CALLS SINT. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE SINTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                  X(I)= THE SUM FROM K=1 TO K=N 
C
C                      4*X(K)*SIN(K*I*PI/(N+1))
C
C                  A CALL OF SINT FOLLOWED BY ANOTHER CALL OF
C                  SINT WILL MULTIPLY THE SEQUENCE X BY 8(N+1)
C                  HENCE SINT IS THE UNNORMALIZED INVERSE
C                  OF ITSELF.
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT BE 
C             DESTROYED BETWEEN CALLS OF SINT.
C
      DIMENSION       X(1)       ,WSAVE(1)
C
      IF (N .GT. 1) GO TO 101
      X(1) = 4.*X(1)
      RETURN
  101 NP1 = N+1
      NS2 = NP1/2
      NS2M = NS2-1 
      IW1 = NS2+1
      X1 = X(1)
      X(1) = 0.
      DO 102 K=1,NS2M
         KC = NP1-K
         T1 = X1-X(KC)
         T2 = WSAVE(K)*(X1+X(KC))
         X1 = X(K+1)
         X(K+1) = T1+T2
         X(KC+1) = T2-T1
  102 CONTINUE
      X(NS2+1) = 4.*X1
      CALL RFFTF (NP1,X,WSAVE(IW1))
      X(1) = .5*X(1)
      DO 103 I=3,N,2
         X(I-1) = X(I+1)
         X(I) = X(I)+X(I-2)
  103 CONTINUE
      RETURN
      END
      SUBROUTINE COSQI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE COSQI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE COSQI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     BOTH COSQF AND COSQB. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED. N MUST BE
C             EVEN 
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5*N+15.
C             THE SAME WORK ARRAY CAN BE USED FOR BOTH COSQF AND COSQB
C             AS LONG AS N REMAINS UNCHANGED. DIFFERENT WSAVE ARRAYS 
C             ARE REQUIRED FOR DIFFERENT VALUES OF N. THE CONTENTS OF
C             WSAVE MUST NOT BE CHANGED BETWEEN CALLS OF COSQF OR COSQB.
C
      DIMENSION       WSAVE(1)
C
      IW1 = N+1
      PIH = 2.*ATAN(1.)
      DT = PIH/FLOAT(N)
      DC = COS(DT) 
      DS = SIN(DT) 
      WSAVE(1) = DC
      WSK = DS
      DO 101 K=2,N 
         WSAVE(K) = DC*WSAVE(K-1)-DS*WSK
         WSK = DS*WSAVE(K-1)+DC*WSK
  101 CONTINUE
      CALL RFFTI (N,WSAVE(IW1))
      RETURN
      END
      SUBROUTINE COSQF (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE COSQF(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE COSQF COMPUTES THE FAST FOURIER TRANSFORM OF QUARTER
C     WAVE DATA. THAT IS , COSQF COMPUTES THE COEFFICIENTS IN A COSINE
C     SERIES REPRESENTATION WITH ONLY ODD WAVE NUMBERS. THE TRANSFORM
C     IS DEFINED BELOW AT OUTPUT PARAMETER X
C
C     COSQF IS THE UNNORMALIZED INVERSE OF COSQB SINCE A CALL OF COSQF
C     FOLLOWED BY A CALL OF COSQB WILL MULTIPLY THE INPUT SEQUENCE X 
C     BY 8*N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE COSQF MUST BE
C     INITIALIZED BY CALLING SUBROUTINE COSQI(N,WSAVE).
C
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY X. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5N+15
C             IN THE PROGRAM THAT CALLS COSQF. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE COSQI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                  X(I)=2*X(1) PLUS THE SUM FROM K=2 TO K=N OF
C
C                     4.*X(K)*COS((2*I-1)*(K-1)*PI/(2*N))
C
C                  A CALL OF COSQF FOLLOWED BY A CALL OF
C                  COSQB WILL MULTIPLY THE SEQUENCE X BY 8*N
C                  THEREFORE COSQB IS THE UNNORMALIZED INVERSE
C                  OF COSQF. 
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT
C             BE DESTROYED BETWEEN CALLS OF COSQF OR COSQB.
C
      DIMENSION       X(1)       ,WSAVE(1)
      DATA TSQ2/2.82842712474619/
C
      IF (N .GT. 2) GO TO 101
      TX = X(1)+X(1)
      TSQX = TSQ2*X(2)
      X(1) = TX+TSQX
      X(2) = TX-TSQX
      RETURN
  101 IW1 = N+1
      IW2 = N/2+IW1
      CALL COSQF1 (N,X,WSAVE,WSAVE(IW1),WSAVE(IW2))
      RETURN
      END
      SUBROUTINE COSQF1 (N,X,W,W1,XH)
      DIMENSION       X(1)       ,XH(1)      ,W1(1)      ,W(1)
      NS2 = N/2
      NM1 = N-1
      NP2 = N+2
      DO 101 K=2,NS2
         KC = NP2-K
         XH(K) = X(K)+X(KC)
         XH(KC) = X(K)-X(KC) 
  101 CONTINUE
      XH(NS2+1) = X(NS2+1)+X(NS2+1)
      DO 102 K=2,NS2
         KC = NP2-K
         X(K) = W(K-1)*XH(KC)+W(KC-1)*XH(K)
         X(KC) = W(K-1)*XH(K)-W(KC-1)*XH(KC)
  102 CONTINUE
      X(NS2+1) = W(NS2)*XH(NS2+1)
      CALL RFFTF (N,X,W1)
      XN = X(2)
      DO 103 I=3,NM1,2
         X(I-1) = X(I)+X(I+1)
         X(I) = X(I)-X(I+1)
  103 CONTINUE
      X(N) = XN
      RETURN
      END
c     SUBROUTINE SINQI (N,WSAVE)
C     ******************************************************************
C
      SUBROUTINE COSQB (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE COSQB(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE COSQB COMPUTES THE FAST FOURIER TRANSFORM OF QUARTER
C     WAVE DATA. THAT IS , COSQB COMPUTES A SEQUENCE FROM ITS
C     REPRESENTATION IN TERMS OF A COSINE SERIES WITH ODD WAVE NUMBERS.
C     THE TRANSFORM IS DEFINED BELOW AT OUTPUT PARAMETER X.
C
C     COSQB IS THE UNNORMALIZED INVERSE OF COSQF SINCE A CALL OF COSQB
C     FOLLOWED BY A CALL OF COSQF WILL MULTIPLY THE INPUT SEQUENCE X 
C     BY 8*N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE COSQB MUST BE
C     INITIALIZED BY CALLING SUBROUTINE COSQI(N,WSAVE).
C
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY X. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5N+15
C             IN THE PROGRAM THAT CALLS COSQB. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE COSQI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                  X(I)= THE SUM FROM K=1 TO K=N OF
C
C                    4*X(K)*COS((2*K-1)*(I-1)*PI/(2*N))
C
C                  A CALL OF COSQB FOLLOWED BY A CALL OF
C                  COSQF WILL MULTIPLY THE SEQUENCE X BY 8*N
C                  THEREFORE COSQF IS THE UNNORMALIZED INVERSE
C                  OF COSQB. 
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT
C             BE DESTROYED BETWEEN CALLS OF COSQB OR COSQF.
C
      DIMENSION       X(1)       ,WSAVE(1)
      DATA TSQ2/2.82842712474619/
C
      IF (N .GT. 2) GO TO 101
      X1 = 4.*(X(1)+X(2))
      X(2) = TSQ2*(X(1)-X(2))
      X(1) = X1
      RETURN
  101 IW1 = N+1
      IW2 = N/2+IW1
      CALL COSQB1 (N,X,WSAVE,WSAVE(IW1),WSAVE(IW2))
      RETURN
      END
      SUBROUTINE COSQB1 (N,X,W,W1,XH)
      DIMENSION       X(1)       ,W(1)       ,W1(1)      ,XH(1)
      NS2 = N/2
      NM1 = N-1
      NP2 = N+2
      XN = X(N)
      DO 101 II=3,NM1,2
         I = NP2-II
         X(I+1) = X(I-1)-X(I)
         X(I) = X(I)+X(I-1)
  101 CONTINUE
      X(1) = X(1)+X(1)
      X(2) = XN+XN 
      CALL RFFTB (N,X,W1)
      DO 102 K=2,NS2
         KC = NP2-K
         XH(K) = W(K-1)*X(KC)+W(KC-1)*X(K)
         XH(KC) = W(K-1)*X(K)-W(KC-1)*X(KC)
  102 CONTINUE
      X(NS2+1) = W(NS2)*(X(NS2+1)+X(NS2+1))
      DO 103 K=2,NS2
         KC = NP2-K
         X(K) = XH(K)+XH(KC) 
         X(KC) = XH(K)-XH(KC)
  103 CONTINUE
      X(1) = X(1)+X(1)
      RETURN
      END
      SUBROUTINE SINQI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE SINQI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE SINQI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     BOTH SINQF AND SINQB. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED. N MUST BE
C             EVEN 
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5*N+15.
C             THE SAME WORK ARRAY CAN BE USED FOR BOTH SINQF AND SINQB
C             AS LONG AS N REMAINS UNCHANGED. DIFFERENT WSAVE ARRAYS 
C             ARE REQUIRED FOR DIFFERENT VALUES OF N. THE CONTENTS OF
C             WSAVE MUST NOT BE CHANGED BETWEEN CALLS OF SINQF OR SINQB.
C
      DIMENSION       WSAVE(1)
C
      CALL COSQI (N,WSAVE)
      RETURN
      END
      SUBROUTINE SINQF (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE SINQF(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE SINQF COMPUTES THE FAST FOURIER TRANSFORM OF QUARTER
C     WAVE DATA. THAT IS , SINQF COMPUTES THE COEFFICIENTS IN A SINE 
C     SERIES REPRESENTATION WITH ONLY ODD WAVE NUMBERS. THE TRANSFORM
C     IS DEFINED BELOW AT OUTPUT PARAMETER X.
C
C     SINQB IS THE UNNORMALIZED INVERSE OF SINQF SINCE A CALL OF SINQF
C     FOLLOWED BY A CALL OF SINQB WILL MULTIPLY THE INPUT SEQUENCE X 
C     BY 8*N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE SINQF MUST BE
C     INITIALIZED BY CALLING SUBROUTINE SINQI(N,WSAVE).
C
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY X. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5N+15
C             IN THE PROGRAM THAT CALLS SINQF. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE SINQI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                  X(I)=2*(-1)**(I+1)*X(N)
C
C                     + THE SUM FROM K=1 TO K=N-1 OF
C
C                     4*X(K)*SIN((2I-1)*K*PI/(2*N))
C
C                  A CALL OF SINQF FOLLOWED BY A CALL OF
C                  SINQB WILL MULTIPLY THE SEQUENCE X BY 8*N
C                  THEREFORE SINQB IS THE UNNORMALIZED INVERSE
C                  OF SINQF. 
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT
C             BE DESTROYED BETWEEN CALLS OF SINQF OR SINQB.
C
      DIMENSION       X(1)       ,WSAVE(1)
C
      NS2 = N/2
      DO 101 K=1,NS2
         KC = N-K
         XHOLD = X(K)
         X(K) = X(KC+1)
         X(KC+1) = XHOLD
  101 CONTINUE
      CALL COSQF (N,X,WSAVE) 
      DO 102 K=2,N,2
         X(K) = -X(K)
  102 CONTINUE
      RETURN
      END
      SUBROUTINE SINQB (N,X,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE SINQB(N,X,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE SINQB COMPUTES THE FAST FOURIER TRANSFORM OF QUARTER
C     WAVE DATA. THAT IS , SINQB COMPUTES A SEQUENCE FROM ITS
C     REPRESENTATION IN TERMS OF A SINE SERIES WITH ODD WAVE NUMBERS.
C     THE TRANSFORM IS DEFINED BELOW AT OUTPUT PARAMETER X.
C
C     SINQF IS THE UNNORMALIZED INVERSE OF SINQB SINCE A CALL OF SINQB
C     FOLLOWED BY A CALL OF SINQF WILL MULTIPLY THE INPUT SEQUENCE X 
C     BY 8*N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE SINQB MUST BE
C     INITIALIZED BY CALLING SUBROUTINE SINQI(N,WSAVE).
C
C
C     INPUT PARAMETERS
C
C     N       THE LENGTH OF THE ARRAY X. N MUST BE EVEN AND THE METHOD
C             IS MOST EFFICIENT WHEN N IS A PRODUCT OF SMALL PRIMES. 
C
C     X       AN ARRAY WHICH CONTAINS THE SEQUENCE TO BE TRANSFORMED 
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 3.5N+15
C             IN THE PROGRAM THAT CALLS SINQB. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE SINQI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C
C     OUTPUT PARAMETERS
C
C     X       FOR I=1,...,N
C
C                  X(I)= THE SUM FROM K=1 TO K=N OF
C
C                    4*X(K)*SIN((2K-1)*I*PI/(2*N))
C
C                  A CALL OF SINQB FOLLOWED BY A CALL OF
C                  SINQF WILL MULTIPLY THE SEQUENCE X BY 8*N
C                  THEREFORE SINQF IS THE UNNORMALIZED INVERSE
C                  OF SINQB. 
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT
C             BE DESTROYED BETWEEN CALLS OF SINQB OR SINQF.
C
      DIMENSION       X(1)       ,WSAVE(1)
C
      NS2 = N/2
      DO 101 K=2,N,2
         X(K) = -X(K)
  101 CONTINUE
      CALL COSQB (N,X,WSAVE) 
      DO 102 K=1,NS2
         KC = N-K
         XHOLD = X(K)
         X(K) = X(KC+1)
         X(KC+1) = XHOLD
  102 CONTINUE
      RETURN
      END
      SUBROUTINE CFFTI (N,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE CFFTI(N,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE CFFTI INITIALIZES THE ARRAY WSAVE WHICH IS USED IN
C     BOTH CFFTF AND CFFTB. THE PRIME FACTORIZATION OF N TOGETHER WITH
C     A TABULATION OF THE TRIGONOMETRIC FUNCTIONS ARE COMPUTED AND
C     STORED IN WSAVE.
C
C     INPUT PARAMETER
C
C     N       THE LENGTH OF THE SEQUENCE TO BE TRANSFORMED 
C
C     OUTPUT PARAMETER
C
C     WSAVE   A WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 4*N+15 
C             THE SAME WORK ARRAY CAN BE USED FOR BOTH CFFTF AND CFFTB
C             AS LONG AS N REMAINS UNCHANGED. DIFFERENT WSAVE ARRAYS 
C             ARE REQUIRED FOR DIFFERENT VALUES OF N. THE CONTENTS OF
C             WSAVE MUST NOT BE CHANGED BETWEEN CALLS OF CFFTF OR CFFTB.
C
      DIMENSION       WSAVE(1)
C
      IF (N .EQ. 1) RETURN
      IW1 = N+N+1
      IW2 = IW1+N+N
      CALL CFFTI1 (N,WSAVE(IW1),WSAVE(IW2))
      RETURN
      END
      SUBROUTINE CFFTI1 (N,WA,IFAC)
      DIMENSION       WA(1)      ,IFAC(1)    ,NTRYH(4)
      DATA NTRYH(1),NTRYH(2),NTRYH(3),NTRYH(4)/3,4,2,5/
      NL = N
      NF = 0
      J = 0
  101 J = J+1
      IF (J-4) 102,102,103
  102 NTRY = NTRYH(J)
      GO TO 104
  103 NTRY = NTRY+2
  104 NQ = NL/NTRY 
      NR = NL-NTRY*NQ
      IF (NR) 101,105,101
  105 NF = NF+1
      IFAC(NF+2) = NTRY
      NL = NQ
      IF (NTRY .NE. 2) GO TO 107
      IF (NF .EQ. 1) GO TO 107
      DO 106 I=2,NF
         IB = NF-I+2
         IFAC(IB+2) = IFAC(IB+1)
  106 CONTINUE
      IFAC(3) = 2
  107 IF (NL .NE. 1) GO TO 104
      IFAC(1) = N
      IFAC(2) = NF 
      TPI = 8.*ATAN(1.)
      ARG1 = TPI/FLOAT(N)
      DC = COS(ARG1)
      DS = SIN(ARG1)
      WA(1) = DC
      WA(2) = DS
      NT = N+N
      DO 108 I=4,NT,2
         WA(I-1) = DC*WA(I-3)-DS*WA(I-2)
         WA(I) = DS*WA(I-3)+DC*WA(I-2) 
  108 CONTINUE
      RETURN
      END
      SUBROUTINE CFFTB (N,C,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE CFFTB(N,C,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE CFFTB COMPUTES THE BACKWARD COMPLEX DISCRETE FOURIER
C     TRANSFORM (THE FOURIER SYNTHESIS). EQUIVALENTLY , CFFTB COMPUTES
C     A COMPLEX PERIODIC SEQUENCE FROM ITS FOURIER COEFFICIENTS.
C     THE TRANSFORM IS DEFINED BELOW AT OUTPUT PARAMETER C.
C
C     A CALL OF CFFTF FOLLOWED BY A CALL OF CFFTB WILL MULTIPLY THE
C     SEQUENCE BY N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE CFFTB MUST BE
C     INITIALIZED BY CALLING SUBROUTINE CFFTI(N,WSAVE).
C
C     INPUT PARAMETERS
C
C
C     N      THE LENGTH OF THE COMPLEX SEQUENCE C. THE METHOD IS
C            MORE EFFICIENT WHEN N IS THE PRODUCT OF SMALL PRIMES.
C
C     C      A COMPLEX ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE 
C
C     WSAVE   A REAL WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 4N+15
C             IN THE PROGRAM THAT CALLS CFFTB. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE CFFTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY CFFTF AND CFFTB.
C
C     OUTPUT PARAMETERS
C
C     C      FOR J=1,...,N
C
C                C(J)=THE SUM FROM K=1,...,N OF
C
C                      C(K)*EXP(I*J*K*2*PI/N)
C
C                            WHERE I=SQRT(-1)
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT BE 
C             DESTROYED BETWEEN CALLS OF SUBROUTINE CFFTF OR CFFTB
      DIMENSION       C(1)       ,WSAVE(1)
C
      IF (N .EQ. 1) RETURN
      IW1 = N+N+1
      IW2 = IW1+N+N
      CALL CFFTB1 (N,C,WSAVE,WSAVE(IW1),WSAVE(IW2))
      RETURN
      END
      SUBROUTINE CFFTB1 (N,C,CH,WA,IFAC)
      DIMENSION       CH(1)      ,C(1)       ,WA(1)      ,IFAC(1)
      NF = IFAC(2) 
      L1 = 1
      DO 105 K1=1,NF
         IP = IFAC(K1+2)
         L2 = IP*L1
         IDO = N/L2
         IDOT = IDO+IDO
         IDL1 = IDOT*L1
         IF (IP .NE. 4) GO TO 101
         IX2 = L1+L1
         IX3 = IX2+L1
         CALL PASSB4 (IDOT,L1,IDL1,IX2,IX3,C,C,C,CH,CH,WA,WA,WA)
         GO TO 104 
  101    IF (IP .NE. 2) GO TO 102
         CALL PASSB2 (IDOT,L1,IDL1,C,C,C,CH,CH,WA)
         GO TO 104 
  102    IF (IP .NE. 3) GO TO 103
         IX2 = L1+L1
         CALL PASSB3 (IDOT,L1,IDL1,IX2,C,C,C,CH,CH,WA,WA)
         GO TO 104 
  103    CALL PASSB (IDOT,IP,L1,IDL1,C,C,C,CH,CH,WA)
  104    L1 = L2
  105 CONTINUE
      RETURN
      END
      SUBROUTINE PASSB2 (IDO,L1,IDL1,CC,C1,C2,CH,CH2,WA1)
      DIMENSION       CC(IDO,2,L1)           ,C1(IDO,L1,2)           ,
     1                C2(IDL1,2) ,CH(IDO,L1,2)           ,CH2(IDL1,2),
     2                WA1(L1,1)
      IDOT = IDO/2 
      IF (IDO .LT. L1) GO TO 103
      DO 102 K=1,L1
         DO 101 I=1,IDO
            CH(I,K,1) = CC(I,1,K)+CC(I,2,K)
            CH(I,K,2) = CC(I,1,K)-CC(I,2,K)
  101    CONTINUE
  102 CONTINUE
      GO TO 106
  103 DO 105 I=1,IDO
         DO 104 K=1,L1
            CH(I,K,1) = CC(I,1,K)+CC(I,2,K)
            CH(I,K,2) = CC(I,1,K)-CC(I,2,K)
  104    CONTINUE
  105 CONTINUE
  106 DO 107 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)
  107 CONTINUE
      DO 108 K=1,L1
         C1(1,K,2) = CH(1,K,2)
         C1(2,K,2) = CH(2,K,2)
  108 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT .LT. L1) GO TO 111
      DO 110 K=1,L1
         DO 109 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
  109    CONTINUE
  110 CONTINUE
      RETURN
  111 DO 113 I=4,IDO,2
         DO 112 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
  112    CONTINUE
  113 CONTINUE
      RETURN
      END
      SUBROUTINE PASSB3 (IDO,L1,IDL1,IX2,CC,C1,C2,CH,CH2,WA1,WA2)
      DIMENSION       CC(IDO,3,L1)           ,C1(IDO,L1,3)           ,
     1                C2(IDL1,3) ,CH(IDO,L1,3)           ,CH2(IDL1,3),
     2                WA1(L1,1)  ,WA2(IX2,1)
      DATA TAUR,TAUI /-.5,.866025403784439/
      IDOT = IDO/2 
      IF (IDO .LT. L1) GO TO 103
      DO 102 K=1,L1
         DO 101 I=1,IDO
            CH(I,K,1) = CC(I,1,K)
            CH(I,K,2) = CC(I,2,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)-CC(I,3,K)
  101    CONTINUE
  102 CONTINUE
      GO TO 106
  103 DO 105 I=1,IDO
         DO 104 K=1,L1
            CH(I,K,1) = CC(I,1,K)
            CH(I,K,2) = CC(I,2,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)-CC(I,3,K)
  104    CONTINUE
  105 CONTINUE
C
  106 DO 107 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)+CH2(IK,2)
         C2(IK,2) = CH2(IK,1)+TAUR*CH2(IK,2)
         C2(IK,3) = TAUI*CH2(IK,3)
  107 CONTINUE
      DO 108 IK=2,IDL1,2
         CH2(IK-1,2) = C2(IK-1,2)-C2(IK,3)
         CH2(IK-1,3) = C2(IK-1,2)+C2(IK,3)
  108 CONTINUE
      DO 109 IK=2,IDL1,2
         CH2(IK,2) = C2(IK,2)+C2(IK-1,3)
         CH2(IK,3) = C2(IK,2)-C2(IK-1,3)
  109 CONTINUE
      DO 111 J=2,3 
         DO 110 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  110    CONTINUE
  111 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT-1 .LT. L1) GO TO 114
      DO 113 K=1,L1
         DO 112 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)+
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)-
     1                    WA2(IX2,I-2)*CH(I,K,3) 
  112    CONTINUE
  113 CONTINUE
      RETURN
  114 DO 116 I=4,IDO,2
         DO 115 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)+
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)-
     1                    WA2(IX2,I-2)*CH(I,K,3) 
  115    CONTINUE
  116 CONTINUE
      RETURN
      END
      SUBROUTINE PASSB4 (IDO,L1,IDL1,IX2,IX3,CC,C1,C2,CH,CH2,WA1,WA2,
     1                   WA3)
      DIMENSION       CC(IDO,4,L1)           ,C1(IDO,L1,4)           ,
     1                C2(IDL1,4) ,CH(IDO,L1,4)           ,CH2(IDL1,4),
     2                WA1(L1,1)  ,WA2(IX2,1) ,WA3(IX3,1)
      IDOT = IDO/2 
C
      IF (IDO .LT. L1) GO TO 106
      DO 103 K=1,L1
         DO 101 I=2,IDO,2
            CH(I-1,K,4) = CC(I,4,K)-CC(I,2,K)
  101    CONTINUE
         DO 102 I=2,IDO,2
            CH(I,K,4) = CC(I-1,2,K)-CC(I-1,4,K)
  102    CONTINUE
  103 CONTINUE
      DO 105 K=1,L1
         DO 104 I=1,IDO
            CH(I,K,2) = CC(I,1,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)+CC(I,4,K)
            CH(I,K,1) = CC(I,1,K)-CC(I,3,K)
  104    CONTINUE
  105 CONTINUE
      GO TO 111
  106 DO 108 I=2,IDO,2
         DO 107 K=1,L1
            CH(I-1,K,4) = CC(I,4,K)-CC(I,2,K)
            CH(I,K,4) = CC(I-1,2,K)-CC(I-1,4,K)
  107    CONTINUE
  108 CONTINUE
      DO 110 I=1,IDO
         DO 109 K=1,L1
            CH(I,K,2) = CC(I,1,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)+CC(I,4,K)
            CH(I,K,1) = CC(I,1,K)-CC(I,3,K)
  109    CONTINUE
  110 CONTINUE
  111 DO 112 IK=1,IDL1
         C2(IK,1) = CH2(IK,2)+CH2(IK,3)
  112 CONTINUE
      DO 113 IK=1,IDL1
         CH2(IK,3) = CH2(IK,2)-CH2(IK,3)
  113 CONTINUE
      DO 114 IK=1,IDL1
         CH2(IK,2) = CH2(IK,1)+CH2(IK,4)
  114 CONTINUE
      DO 115 IK=1,IDL1
         CH2(IK,4) = CH2(IK,1)-CH2(IK,4)
  115 CONTINUE
      DO 117 J=2,4 
         DO 116 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  116    CONTINUE
  117 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT .LT. L1) GO TO 120
      DO 119 K=1,L1
         DO 118 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)+
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)-
     1                    WA2(IX2,I-2)*CH(I,K,3) 
            C1(I,K,4) = WA3(IX3-1,I-2)*CH(I,K,4)+
     1                  WA3(IX3,I-2)*CH(I-1,K,4) 
            C1(I-1,K,4) = WA3(IX3-1,I-2)*CH(I-1,K,4)-
     1                    WA3(IX3,I-2)*CH(I,K,4) 
  118    CONTINUE
  119 CONTINUE
      RETURN
  120 DO 122 I=4,IDO,2
         DO 121 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)+WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)-
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)+
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)-
     1                    WA2(IX2,I-2)*CH(I,K,3) 
            C1(I,K,4) = WA3(IX3-1,I-2)*CH(I,K,4)+
     1                  WA3(IX3,I-2)*CH(I-1,K,4) 
            C1(I-1,K,4) = WA3(IX3-1,I-2)*CH(I-1,K,4)-
     1                    WA3(IX3,I-2)*CH(I,K,4) 
  121    CONTINUE
  122 CONTINUE
      RETURN
      END
      SUBROUTINE PASSB (IDO,IP,L1,IDL1,CC,C1,C2,CH,CH2,WA) 
      DIMENSION       CH(IDO,L1,IP)          ,CC(IDO,IP,L1)          ,
     1                C1(IDO,L1,IP)          ,WA(1)      ,C2(IDL1,IP),
     2                CH2(IDL1,IP)
      IDOT = IDO/2 
      NT = IP*IDL1 
      IPP2 = IP+2
      IPPH = (IP+1)/2
      L1T = L1+L1
C
      IF (IDO .LT. L1) GO TO 106
      DO 103 J=2,IPPH
         JC = IPP2-J
         DO 102 K=1,L1
            DO 101 I=1,IDO
               CH(I,K,J) = CC(I,J,K)+CC(I,JC,K)
               CH(I,K,JC) = CC(I,J,K)-CC(I,JC,K) 
  101       CONTINUE
  102    CONTINUE
  103 CONTINUE
      DO 105 K=1,L1
         DO 104 I=1,IDO
            CH(I,K,1) = CC(I,1,K)
  104    CONTINUE
  105 CONTINUE
      GO TO 112
  106 DO 109 J=2,IPPH
         JC = IPP2-J
         DO 108 I=1,IDO
            DO 107 K=1,L1
               CH(I,K,J) = CC(I,J,K)+CC(I,JC,K)
               CH(I,K,JC) = CC(I,J,K)-CC(I,JC,K) 
  107       CONTINUE
  108    CONTINUE
  109 CONTINUE
      DO 111 I=1,IDO
         DO 110 K=1,L1
            CH(I,K,1) = CC(I,1,K)
  110    CONTINUE
  111 CONTINUE
  112 DO 113 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)
  113 CONTINUE
      IDJ = 0
      DO 115 J=2,IPPH
         JC = IPP2-J
         IDJ = IDJ+IDL1
         DO 114 IK=1,IDL1
            C2(IK,J) = CH2(IK,1)+WA(IDJ-1)*CH2(IK,2)
            C2(IK,JC) = WA(IDJ)*CH2(IK,IP)
  114    CONTINUE
  115 CONTINUE
      DO 117 J=2,IPPH
         DO 116 IK=1,IDL1
            C2(IK,1) = C2(IK,1)+CH2(IK,J)
  116    CONTINUE
  117 CONTINUE
C
      IDL = 0
      DO 120 L=2,IPPH
         LC = IPP2-L
         IDL = IDL+IDL1
         IDLJ = IDL
         DO 119 J=3,IPPH
            JC = IPP2-J
            IDLJ = IDLJ+IDL
            IF (IDLJ .GT. NT) IDLJ = IDLJ-NT
            WAR = WA(IDLJ-1) 
            WAI = WA(IDLJ)
            DO 118 IK=1,IDL1 
               C2(IK,L) = C2(IK,L)+WAR*CH2(IK,J) 
               C2(IK,LC) = C2(IK,LC)+WAI*CH2(IK,JC)
  118       CONTINUE
  119    CONTINUE
  120 CONTINUE
C
      DO 122 J=2,IPPH
         JC = IPP2-J
         DO 121 IK=2,IDL1,2
            CH2(IK-1,J) = C2(IK-1,J)-C2(IK,JC)
            CH2(IK-1,JC) = C2(IK-1,J)+C2(IK,JC)
  121    CONTINUE
  122 CONTINUE
      DO 124 J=2,IPPH
         JC = IPP2-J
         DO 123 IK=2,IDL1,2
            CH2(IK,J) = C2(IK,J)+C2(IK-1,JC)
            CH2(IK,JC) = C2(IK,J)-C2(IK-1,JC)
  123    CONTINUE
  124 CONTINUE
C
      DO 126 J=2,IP
         DO 125 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  125    CONTINUE
  126 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IDJ = 0
      IF (IDOT .GT. L1) GO TO 130
      DO 129 J=2,IP
         IDJ = IDJ+L1T
         IDIJ = 0
         DO 128 I=4,IDO,2
            IDIJ = IDIJ+IDJ
            DO 127 K=1,L1
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)-WA(IDIJ)*CH(I,K,J)
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)+WA(IDIJ)*CH(I-1,K,J) 
  127       CONTINUE
  128    CONTINUE
  129 CONTINUE
      RETURN
  130 DO 134 J=2,IP
         IDJ = IDJ+L1T
         DO 133 K=1,L1
            IDIJ = 0
            DO 131 I=4,IDO,2 
               IDIJ = IDIJ+IDJ
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)-WA(IDIJ)*CH(I,K,J)
  131       CONTINUE
            IDIJ = 0
            DO 132 I=4,IDO,2 
               IDIJ = IDIJ+IDJ
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)+WA(IDIJ)*CH(I-1,K,J) 
  132       CONTINUE
  133    CONTINUE
  134 CONTINUE
      RETURN
      END
      SUBROUTINE CFFTF (N,C,WSAVE)
C     ******************************************************************
C
C     SUBROUTINE CFFTF(N,C,WSAVE)
C
C     ******************************************************************
C
C     SUBROUTINE CFFTF COMPUTES THE FORWARD COMPLEX DISCRETE FOURIER 
C     TRANSFORM (THE FOURIER ANALYSIS). EQUIVALENTLY , CFFTF COMPUTES
C     THE FOURIER COEFFICIENTS OF A COMPLEX PERIODIC SEQUENCE.
C     THE TRANSFORM IS DEFINED BELOW AT OUTPUT PARAMETER C.
C
C     THE TRANSFORM IS NOT NORMALIZED. TO OBTAIN A NORMALIZED TRANSFORM
C     THE OUTPUT MUST BE DIVIDED BY N. OTHERWISE A CALL OF CFFTF
C     FOLLOWED BY A CALL OF CFFTB WILL MULTIPLY THE SEQUENCE BY N.
C
C     THE ARRAY WSAVE WHICH IS USED BY SUBROUTINE CFFTF MUST BE
C     INITIALIZED BY CALLING SUBROUTINE CFFTI(N,WSAVE).
C
C     INPUT PARAMETERS
C
C
C     N      THE LENGTH OF THE COMPLEX SEQUENCE C. THE METHOD IS
C            MORE EFFICIENT WHEN N IS THE PRODUCT OF SMALL PRIMES. N 
C
C     C      A COMPLEX ARRAY OF LENGTH N WHICH CONTAINS THE SEQUENCE 
C
C     WSAVE   A REAL WORK ARRAY WHICH MUST BE DIMENSIONED AT LEAST 4N+15
C             IN THE PROGRAM THAT CALLS CFFTF. THE WSAVE ARRAY MUST BE
C             INITIALIZED BY CALLING SUBROUTINE CFFTI(N,WSAVE) AND A 
C             DIFFERENT WSAVE ARRAY MUST BE USED FOR EACH DIFFERENT
C             VALUE OF N. THIS INITIALIZATION DOES NOT HAVE TO BE
C             REPEATED SO LONG AS N REMAINS UNCHANGED THUS SUBSEQUENT
C             TRANSFORMS CAN BE OBTAINED FASTER THAN THE FIRST.
C             THE SAME WSAVE ARRAY CAN BE USED BY CFFTF AND CFFTB.
C
C     OUTPUT PARAMETERS
C
C     C      FOR J=1,...,N
C
C                C(J)=THE SUM FROM K=1,...,N OF
C
C                      C(K)*EXP(-I*J*K*2*PI/N)
C
C                            WHERE I=SQRT(-1)
C
C     WSAVE   CONTAINS INITIALIZATION CALCULATIONS WHICH MUST NOT BE 
C             DESTROYED BETWEEN CALLS OF SUBROUTINE CFFTF OR CFFTB
C
      DIMENSION       C(1)       ,WSAVE(1)
C
      IF (N .EQ. 1) RETURN
      IW1 = N+N+1
      IW2 = IW1+N+N
      CALL CFFTF1 (N,C,WSAVE,WSAVE(IW1),WSAVE(IW2))
      RETURN
      END
      SUBROUTINE CFFTF1 (N,C,CH,WA,IFAC)
      DIMENSION       CH(1)      ,C(1)       ,WA(1)      ,IFAC(1)
      NF = IFAC(2) 
      L1 = 1
      DO 105 K1=1,NF
         IP = IFAC(K1+2)
         L2 = IP*L1
         IDO = N/L2
         IDOT = IDO+IDO
         IDL1 = IDOT*L1
         IF (IP .NE. 4) GO TO 101
         IX2 = L1+L1
         IX3 = IX2+L1
         CALL PASSF4 (IDOT,L1,IDL1,IX2,IX3,C,C,C,CH,CH,WA,WA,WA)
         GO TO 104 
  101    IF (IP .NE. 2) GO TO 102
         CALL PASSF2 (IDOT,L1,IDL1,C,C,C,CH,CH,WA)
         GO TO 104 
  102    IF (IP .NE. 3) GO TO 103
         IX2 = L1+L1
         CALL PASSF3 (IDOT,L1,IDL1,IX2,C,C,C,CH,CH,WA,WA)
         GO TO 104 
  103    CALL PASSF (IDOT,IP,L1,IDL1,C,C,C,CH,CH,WA)
  104    L1 = L2
  105 CONTINUE
      RETURN
      END
      SUBROUTINE PASSF2 (IDO,L1,IDL1,CC,C1,C2,CH,CH2,WA1)
      DIMENSION       CC(IDO,2,L1)           ,C1(IDO,L1,2)           ,
     1                C2(IDL1,2) ,CH(IDO,L1,2)           ,CH2(IDL1,2),
     2                WA1(L1,1)
      IDOT = IDO/2 
      IF (IDO .LT. L1) GO TO 103
      DO 102 K=1,L1
         DO 101 I=1,IDO
            CH(I,K,1) = CC(I,1,K)+CC(I,2,K)
            CH(I,K,2) = CC(I,1,K)-CC(I,2,K)
  101    CONTINUE
  102 CONTINUE
      GO TO 106
  103 DO 105 I=1,IDO
         DO 104 K=1,L1
            CH(I,K,1) = CC(I,1,K)+CC(I,2,K)
            CH(I,K,2) = CC(I,1,K)-CC(I,2,K)
  104    CONTINUE
  105 CONTINUE
  106 DO 107 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)
  107 CONTINUE
      DO 108 K=1,L1
         C1(1,K,2) = CH(1,K,2)
         C1(2,K,2) = CH(2,K,2)
  108 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT .LT. L1) GO TO 111
      DO 110 K=1,L1
         DO 109 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
  109    CONTINUE
  110 CONTINUE
      RETURN
  111 DO 113 I=4,IDO,2
         DO 112 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
  112    CONTINUE
  113 CONTINUE
      RETURN
      END
      SUBROUTINE PASSF3 (IDO,L1,IDL1,IX2,CC,C1,C2,CH,CH2,WA1,WA2)
      DIMENSION       CC(IDO,3,L1)           ,C1(IDO,L1,3)           ,
     1                C2(IDL1,3) ,CH(IDO,L1,3)           ,CH2(IDL1,3),
     2                WA1(L1,1)  ,WA2(IX2,1)
      DATA TAUR,TAUI /-.5,-.866025403784439/
      IDOT = IDO/2 
      IF (IDO .LT. L1) GO TO 103
      DO 102 K=1,L1
         DO 101 I=1,IDO
            CH(I,K,1) = CC(I,1,K)
            CH(I,K,2) = CC(I,2,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)-CC(I,3,K)
  101    CONTINUE
  102 CONTINUE
      GO TO 106
  103 DO 105 I=1,IDO
         DO 104 K=1,L1
            CH(I,K,1) = CC(I,1,K)
            CH(I,K,2) = CC(I,2,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)-CC(I,3,K)
  104    CONTINUE
  105 CONTINUE
C
  106 DO 107 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)+CH2(IK,2)
         C2(IK,2) = CH2(IK,1)+TAUR*CH2(IK,2)
         C2(IK,3) = TAUI*CH2(IK,3)
  107 CONTINUE
      DO 108 IK=2,IDL1,2
         CH2(IK-1,2) = C2(IK-1,2)-C2(IK,3)
         CH2(IK-1,3) = C2(IK-1,2)+C2(IK,3)
  108 CONTINUE
      DO 109 IK=2,IDL1,2
         CH2(IK,2) = C2(IK,2)+C2(IK-1,3)
         CH2(IK,3) = C2(IK,2)-C2(IK-1,3)
  109 CONTINUE
      DO 111 J=2,3 
         DO 110 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  110    CONTINUE
  111 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT-1 .LT. L1) GO TO 114
      DO 113 K=1,L1
         DO 112 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)-
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)+
     1                    WA2(IX2,I-2)*CH(I,K,3) 
  112    CONTINUE
  113 CONTINUE
      RETURN
  114 DO 116 I=4,IDO,2
         DO 115 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)-
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)+
     1                    WA2(IX2,I-2)*CH(I,K,3) 
  115    CONTINUE
  116 CONTINUE
      RETURN
      END
      SUBROUTINE PASSF4 (IDO,L1,IDL1,IX2,IX3,CC,C1,C2,CH,CH2,WA1,WA2,
     1                   WA3)
      DIMENSION       CC(IDO,4,L1)           ,C1(IDO,L1,4)           ,
     1                C2(IDL1,4) ,CH(IDO,L1,4)           ,CH2(IDL1,4),
     2                WA1(L1,1)  ,WA2(IX2,1) ,WA3(IX3,1)
      IDOT = IDO/2 
C
      IF (IDO .LT. L1) GO TO 106
      DO 103 K=1,L1
         DO 101 I=2,IDO,2
            CH(I-1,K,4) = CC(I,2,K)-CC(I,4,K)
  101    CONTINUE
         DO 102 I=2,IDO,2
            CH(I,K,4) = CC(I-1,4,K)-CC(I-1,2,K)
  102    CONTINUE
  103 CONTINUE
      DO 105 K=1,L1
         DO 104 I=1,IDO
            CH(I,K,2) = CC(I,1,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)+CC(I,4,K)
            CH(I,K,1) = CC(I,1,K)-CC(I,3,K)
  104    CONTINUE
  105 CONTINUE
      GO TO 111
  106 DO 108 I=2,IDO,2
         DO 107 K=1,L1
            CH(I,K,4) = CC(I-1,4,K)-CC(I-1,2,K)
            CH(I-1,K,4) = CC(I,2,K)-CC(I,4,K)
  107    CONTINUE
  108 CONTINUE
      DO 110 I=1,IDO
         DO 109 K=1,L1
            CH(I,K,2) = CC(I,1,K)+CC(I,3,K)
            CH(I,K,3) = CC(I,2,K)+CC(I,4,K)
            CH(I,K,1) = CC(I,1,K)-CC(I,3,K)
  109    CONTINUE
  110 CONTINUE
  111 DO 112 IK=1,IDL1
         C2(IK,1) = CH2(IK,2)+CH2(IK,3)
  112 CONTINUE
      DO 113 IK=1,IDL1
         CH2(IK,3) = CH2(IK,2)-CH2(IK,3)
  113 CONTINUE
      DO 114 IK=1,IDL1
         CH2(IK,2) = CH2(IK,1)+CH2(IK,4)
  114 CONTINUE
      DO 115 IK=1,IDL1
         CH2(IK,4) = CH2(IK,1)-CH2(IK,4)
  115 CONTINUE
      DO 117 J=2,4 
         DO 116 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  116    CONTINUE
  117 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IF (IDOT .LT. L1) GO TO 120
      DO 119 K=1,L1
         DO 118 I=4,IDO,2
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)-
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)+
     1                    WA2(IX2,I-2)*CH(I,K,3) 
            C1(I,K,4) = WA3(IX3-1,I-2)*CH(I,K,4)-
     1                  WA3(IX3,I-2)*CH(I-1,K,4) 
            C1(I-1,K,4) = WA3(IX3-1,I-2)*CH(I-1,K,4)+
     1                    WA3(IX3,I-2)*CH(I,K,4) 
  118    CONTINUE
  119 CONTINUE
      RETURN
  120 DO 122 I=4,IDO,2
         DO 121 K=1,L1
            C1(I,K,2) = WA1(L1-1,I-2)*CH(I,K,2)-WA1(L1,I-2)*CH(I-1,K,2)
            C1(I-1,K,2) = WA1(L1-1,I-2)*CH(I-1,K,2)+
     1                    WA1(L1,I-2)*CH(I,K,2)
            C1(I,K,3) = WA2(IX2-1,I-2)*CH(I,K,3)-
     1                  WA2(IX2,I-2)*CH(I-1,K,3) 
            C1(I-1,K,3) = WA2(IX2-1,I-2)*CH(I-1,K,3)+
     1                    WA2(IX2,I-2)*CH(I,K,3) 
            C1(I,K,4) = WA3(IX3-1,I-2)*CH(I,K,4)-
     1                  WA3(IX3,I-2)*CH(I-1,K,4) 
            C1(I-1,K,4) = WA3(IX3-1,I-2)*CH(I-1,K,4)+
     1                    WA3(IX3,I-2)*CH(I,K,4) 
  121    CONTINUE
  122 CONTINUE
      RETURN
      END
      SUBROUTINE PASSF (IDO,IP,L1,IDL1,CC,C1,C2,CH,CH2,WA) 
      DIMENSION       CH(IDO,L1,IP)          ,CC(IDO,IP,L1)          ,
     1                C1(IDO,L1,IP)          ,WA(1)      ,C2(IDL1,IP),
     2                CH2(IDL1,IP)
      IDOT = IDO/2 
      NT = IP*IDL1 
      IPP2 = IP+2
      IPPH = (IP+1)/2
      L1T = L1+L1
C
      IF (IDO .LT. L1) GO TO 106
      DO 103 J=2,IPPH
         JC = IPP2-J
         DO 102 K=1,L1
            DO 101 I=1,IDO
               CH(I,K,J) = CC(I,J,K)+CC(I,JC,K)
               CH(I,K,JC) = CC(I,J,K)-CC(I,JC,K) 
  101       CONTINUE
  102    CONTINUE
  103 CONTINUE
      DO 105 K=1,L1
         DO 104 I=1,IDO
            CH(I,K,1) = CC(I,1,K)
  104    CONTINUE
  105 CONTINUE
      GO TO 112
  106 DO 109 J=2,IPPH
         JC = IPP2-J
         DO 108 I=1,IDO
            DO 107 K=1,L1
               CH(I,K,J) = CC(I,J,K)+CC(I,JC,K)
               CH(I,K,JC) = CC(I,J,K)-CC(I,JC,K) 
  107       CONTINUE
  108    CONTINUE
  109 CONTINUE
      DO 111 I=1,IDO
         DO 110 K=1,L1
            CH(I,K,1) = CC(I,1,K)
  110    CONTINUE
  111 CONTINUE
  112 DO 113 IK=1,IDL1
         C2(IK,1) = CH2(IK,1)
  113 CONTINUE
      IDJ = 0
      DO 115 J=2,IPPH
         JC = IPP2-J
         IDJ = IDJ+IDL1
         DO 114 IK=1,IDL1
            C2(IK,J) = CH2(IK,1)+WA(IDJ-1)*CH2(IK,2)
            C2(IK,JC) = -WA(IDJ)*CH2(IK,IP)
  114    CONTINUE
  115 CONTINUE
      DO 117 J=2,IPPH
         DO 116 IK=1,IDL1
            C2(IK,1) = C2(IK,1)+CH2(IK,J)
  116    CONTINUE
  117 CONTINUE
C
      IDL = 0
      DO 120 L=2,IPPH
         LC = IPP2-L
         IDL = IDL+IDL1
         IDLJ = IDL
         DO 119 J=3,IPPH
            JC = IPP2-J
            IDLJ = IDLJ+IDL
            IF (IDLJ .GT. NT) IDLJ = IDLJ-NT
            WAR = WA(IDLJ-1) 
            WAI = WA(IDLJ)
            DO 118 IK=1,IDL1 
               C2(IK,L) = C2(IK,L)+WAR*CH2(IK,J) 
               C2(IK,LC) = C2(IK,LC)-WAI*CH2(IK,JC)
  118       CONTINUE
  119    CONTINUE
  120 CONTINUE
C
      DO 122 J=2,IPPH
         JC = IPP2-J
         DO 121 IK=2,IDL1,2
            CH2(IK-1,J) = C2(IK-1,J)-C2(IK,JC)
            CH2(IK-1,JC) = C2(IK-1,J)+C2(IK,JC)
  121    CONTINUE
  122 CONTINUE
      DO 124 J=2,IPPH
         JC = IPP2-J
         DO 123 IK=2,IDL1,2
            CH2(IK,J) = C2(IK,J)+C2(IK-1,JC)
            CH2(IK,JC) = C2(IK,J)-C2(IK-1,JC)
  123    CONTINUE
  124 CONTINUE
C
      DO 126 J=2,IP
         DO 125 K=1,L1
            C1(1,K,J) = CH(1,K,J)
            C1(2,K,J) = CH(2,K,J)
  125    CONTINUE
  126 CONTINUE
      IF (IDO .EQ. 2) RETURN 
      IDJ = 0
      IF (IDOT .GT. L1) GO TO 130
      DO 129 J=2,IP
         IDJ = IDJ+L1T
         IDIJ = 0
         DO 128 I=4,IDO,2
            IDIJ = IDIJ+IDJ
            DO 127 K=1,L1
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)+WA(IDIJ)*CH(I,K,J)
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)-WA(IDIJ)*CH(I-1,K,J) 
  127       CONTINUE
  128    CONTINUE
  129 CONTINUE
      RETURN
  130 DO 134 J=2,IP
         IDJ = IDJ+L1T
         DO 133 K=1,L1
            IDIJ = 0
            DO 131 I=4,IDO,2 
               IDIJ = IDIJ+IDJ
               C1(I-1,K,J) = WA(IDIJ-1)*CH(I-1,K,J)+WA(IDIJ)*CH(I,K,J)
  131       CONTINUE
            IDIJ = 0
            DO 132 I=4,IDO,2 
               IDIJ = IDIJ+IDJ
               C1(I,K,J) = WA(IDIJ-1)*CH(I,K,J)-WA(IDIJ)*CH(I-1,K,J) 
  132       CONTINUE
  133    CONTINUE
  134 CONTINUE
      RETURN
      END

